//#define POD_DEBUG

template<unsigned int dim>
coupling::noisereduction::POD<dim>::POD(
  const coupling::IndexConversion<dim> &indexConversion,
  const tarch::utils::MultiMDService<dim>& multiMDService,
  int tws, int kmax
):
coupling::noisereduction::NoiseReduction<dim>(indexConversion, multiMDService, true),
_timeWindowSize(tws),
_kMax(kmax),
_cycleCounter(0),
_spatialIndex(0),
_t(0),
_data(NULL),
_C(NULL),
_A(NULL),
_A_T(NULL),
_firstTraversal(true)
{
  int spatialSize = getLocalNumberMacroscopicCells(indexConversion);
  _data = new Eigen::MatrixXd[dim+1]; // separate data matrices for: mass, momentum0, momentum1, momentum2
  _C = new Eigen::MatrixXd[dim+1];
  _A = new Eigen::MatrixXd[dim+1];
  _A_T = new Eigen::MatrixXd[dim+1];
  for(unsigned int i=0;i<dim+1;i++){
    _data[i] = Eigen::MatrixXd::Constant(_timeWindowSize, spatialSize, (i==0)?1:0);
  }
  //std::cout << "POD kmax = " << _kMax << ", and tws = " << _timeWindowSize << std::endl;
}

template<unsigned int dim>
coupling::noisereduction::POD<dim>::~POD(){
  if (_data!=NULL){ delete [] _data; _data=NULL;}
  if (_C!=NULL){ delete [] _C; _C=NULL;}
  if (_A!=NULL){ delete [] _A; _A=NULL;}
  if (_A_T!=NULL){ delete [] _A_T; _A_T=NULL;}
}


template<unsigned int dim>
void coupling::noisereduction::POD<dim>::
beginProcessInnerMacroscopicCells(){
  _spatialIndex = 0;

  if(!_firstTraversal){
    for (unsigned int d = 0; d < dim+1; d++){
      // @todo write this in more efficient iterative form, 
      // updating just one single column instead of everything
      // and compute only lower triangular part!
      _C[d] = _data[d] * _data[d].transpose(); 

      #ifdef POD_DEBUG
      #if (COUPLING_MD_PARALLEL==COUPLING_MD_YES)
      for(unsigned int rank = 0; rank<coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalSize(); rank++){
        if(rank == coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank()){
      #endif
        std::cout << "Rank " << coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank()
          << ", _cycleCounter " << _cycleCounter << ": _data["<<d<<"] = " << _data[d] << std::endl;
        std::cout << "Rank " << coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank()
          << ", _cycleCounter " << _cycleCounter << ": _C["<<d<<"] = " << _C[d] << std::endl;
      #if (COUPLING_MD_PARALLEL==COUPLING_MD_YES)
        }
        MPI_Barrier(coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalCommunicator());
      }
      #endif
      #endif 
    }

    // @todo asynchronous allreduce! (but doesnt make sense currently, without interleaved computation)
    #if (COUPLING_MD_PARALLEL==COUPLING_MD_YES)
    const unsigned int count = _timeWindowSize*_timeWindowSize*(dim+1);
    double *send_data = new double[count];
    double *recv_data = new double[count];
    // Fill one common send buffer for all dimensions
    unsigned int index = 0;
    for (unsigned int d = 0; d < dim+1; d++)
      for(unsigned int i = 0; i < _timeWindowSize*_timeWindowSize; i++)
        send_data[index++] = _C[d].data()[i];
    MPI_Allreduce(send_data, recv_data, count, MPI_DOUBLE, MPI_SUM, 
      coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalCommunicator());
    for (unsigned int d = 0; d < dim+1; d++){
      Eigen::Map<Eigen::MatrixXd> map(&recv_data[d*_timeWindowSize*_timeWindowSize], _timeWindowSize, _timeWindowSize);
      _C[d] = map;  // copy assignment
    }
    delete [] send_data;
    delete [] recv_data;
    #endif

    for (unsigned int d = 0; d < dim+1; d++){
      #ifdef POD_DEBUG
      #if (COUPLING_MD_PARALLEL==COUPLING_MD_YES)
      for(unsigned int rank = 0; rank<coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalSize(); rank++){
        if(rank == coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank()){
      #endif
          std::cout << "Rank " << coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank()
            << ", _cycleCounter " << _cycleCounter << ": Communication finished" << std::endl;
          std::cout << "Rank " << coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank()
            << ", _cycleCounter " << _cycleCounter << ": _C["<<d<<"] = " << _C[d] << std::endl;
      #if (COUPLING_MD_PARALLEL==COUPLING_MD_YES)
        }
        MPI_Barrier(coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalCommunicator());
      }
      #endif
      #endif
      Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> solver(_C[d]);

      _A[d] = solver.eigenvectors().rightCols(_kMax);
      _A_T[d] = _A[d].transpose();
    }
  }
}


template<unsigned int dim>
void coupling::noisereduction::POD<dim>::
processInnerMacroscopicCell(
coupling::datastructures::MacroscopicCell<dim> &cell, const unsigned int &index){
  if(_firstTraversal){
    // save data into snapshot matrix
    _data[0](_t, _spatialIndex) = cell.getMacroscopicMass();
    for (unsigned int d = 0; d < dim; d++){    // (optimized compiler will unroll this loop)
      _data[d+1](_t, _spatialIndex) = cell.getMacroscopicMomentum()[d];
    }
  } else {
    // compute and store smoothed result
    Eigen::VectorXd phi_x = _A_T[0] * _data[0].col(_spatialIndex);
    cell.setMacroscopicMass((_A[0].row(_t) * phi_x).value());
    tarch::la::Vector<dim,double> mo_smooth;
    for (unsigned int d = 0; d < dim; d++){ // (optimized compiler will unroll this loop)
      phi_x = _A_T[d+1] * _data[d+1].col(_spatialIndex);
      mo_smooth[d] = (_A[d+1].row(_t) * phi_x).value();
    }
    cell.setMacroscopicMomentum(mo_smooth);
  }
  _spatialIndex++;
}


template<unsigned int dim>
void coupling::noisereduction::POD<dim>::
endProcessInnerMacroscopicCells(){
  if(!_firstTraversal){
    _cycleCounter++;
    _t = _cycleCounter%_timeWindowSize;
  }
  _firstTraversal = !_firstTraversal;
}

template<unsigned int dim>
unsigned int coupling::noisereduction::POD<dim>::getLocalNumberMacroscopicCells(const coupling::IndexConversion<dim> &indexConversion) const{
  const tarch::la::Vector<dim,unsigned int> localCells(indexConversion.getLocalNumberMacroscopicCells());
  unsigned int num = localCells[0]; for (unsigned int d = 1; d < dim; d++){ num = num * localCells[d]; }
  return num;
}
