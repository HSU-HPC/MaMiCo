//#define POD_DEBUG

template <unsigned int dim>
coupling::noisereduction::POD<dim>::POD(const coupling::IndexConversion<dim> &indexConversion, const tarch::utils::MultiMDService<dim> &multiMDService, int tws,
                                        int kmax)
    : coupling::noisereduction::NoiseReduction<dim>(indexConversion, multiMDService, true), _timeWindowSize(tws), _kMax(kmax), _cycleCounter(0),
      _spatialIndex(0), _t(0), _data(NULL), _C(NULL), _A(NULL), _A_T(NULL), _firstTraversal(true) {
  int spatialSize = getLocalNumberMacroscopicCells(indexConversion);
  _data = new Eigen::MatrixXd[dim + 1]; // separate data matrices for: mass,
                                        // momentum0, momentum1, momentum2
  _C = new Eigen::MatrixXd[dim + 1];
  _A = new Eigen::MatrixXd[dim + 1];
  _A_T = new Eigen::MatrixXd[dim + 1];
  for (unsigned int i = 0; i < dim + 1; i++) {
    _data[i] = Eigen::MatrixXd::Constant(_timeWindowSize, spatialSize, (i == 0) ? 1 : 0);
  }
  // std::cout << "POD kmax = " << _kMax << ", and tws = " << _timeWindowSize <<
  // std::endl;
}

template <unsigned int dim> coupling::noisereduction::POD<dim>::~POD() {
  if (_data != NULL) {
    delete[] _data;
    _data = NULL;
  }
  if (_C != NULL) {
    delete[] _C;
    _C = NULL;
  }
  if (_A != NULL) {
    delete[] _A;
    _A = NULL;
  }
  if (_A_T != NULL) {
    delete[] _A_T;
    _A_T = NULL;
  }
}

template <unsigned int dim> void coupling::noisereduction::POD<dim>::beginProcessInnerMacroscopicCells() {
  _spatialIndex = 0;

  if (!_firstTraversal) {
    for (unsigned int d = 0; d < dim + 1; d++) {
      // @todo write this in more efficient iterative form,
      // updating just one single column instead of everything
      // and compute only lower triangular part!
      _C[d] = _data[d] * _data[d].transpose();

#ifdef POD_DEBUG
#if (COUPLING_MD_PARALLEL == COUPLING_MD_YES)
      for (unsigned int rank = 0; rank < coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalSize(); rank++) {
        if (rank == coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank()) {
#endif
          std::cout << "Rank " << coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank() << ", _cycleCounter " << _cycleCounter
                    << ": _data[" << d << "] = " << _data[d] << std::endl;
          std::cout << "Rank " << coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank() << ", _cycleCounter " << _cycleCounter
                    << ": _C[" << d << "] = " << _C[d] << std::endl;
#if (COUPLING_MD_PARALLEL == COUPLING_MD_YES)
        }
        MPI_Barrier(coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalCommunicator());
      }
#endif
#endif
    }

// @todo asynchronous allreduce! (but doesnt make sense currently, without
// interleaved computation)
#if (COUPLING_MD_PARALLEL == COUPLING_MD_YES)
    const unsigned int count = _timeWindowSize * _timeWindowSize * (dim + 1);
    double *send_data = new double[count];
    double *recv_data = new double[count];
    // Fill one common send buffer for all dimensions
    unsigned int index = 0;
    for (unsigned int d = 0; d < dim + 1; d++)
      for (unsigned int i = 0; i < _timeWindowSize * _timeWindowSize; i++)
        send_data[index++] = _C[d].data()[i];
    MPI_Allreduce(send_data, recv_data, count, MPI_DOUBLE, MPI_SUM, coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalCommunicator());
    for (unsigned int d = 0; d < dim + 1; d++) {
      Eigen::Map<Eigen::MatrixXd> map(&recv_data[d * _timeWindowSize * _timeWindowSize], _timeWindowSize, _timeWindowSize);
      _C[d] = map; // copy assignment
    }
    delete[] send_data;
    delete[] recv_data;
#endif

    for (unsigned int d = 0; d < dim + 1; d++) {
#ifdef POD_DEBUG
#if (COUPLING_MD_PARALLEL == COUPLING_MD_YES)
      for (unsigned int rank = 0; rank < coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalSize(); rank++) {
        if (rank == coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank()) {
#endif
          std::cout << "Rank " << coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank() << ", _cycleCounter " << _cycleCounter
                    << ": Communication finished" << std::endl;
          std::cout << "Rank " << coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalRank() << ", _cycleCounter " << _cycleCounter
                    << ": _C[" << d << "] = " << _C[d] << std::endl;
#if (COUPLING_MD_PARALLEL == COUPLING_MD_YES)
        }
        MPI_Barrier(coupling::noisereduction::NoiseReduction<dim>::_multiMDService.getLocalCommunicator());
      }
#endif
#endif
      Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> solver(_C[d]);

      _A[d] = solver.eigenvectors().rightCols(_kMax);
      _A_T[d] = _A[d].transpose();
    }
  }
}

template <unsigned int dim>
void coupling::noisereduction::POD<dim>::processInnerMacroscopicCell(coupling::datastructures::MacroscopicCell<dim> &cell, const unsigned int &index) {
  if (_firstTraversal) {
    // save data into snapshot matrix
    _data[0](_t, _spatialIndex) = cell.getMacroscopicMass();
    for (unsigned int d = 0; d < dim; d++) { // (optimized compiler will unroll this loop)
      _data[d + 1](_t, _spatialIndex) = cell.getMacroscopicMomentum()[d];
    }
  } else {
    // compute and store smoothed result
    Eigen::VectorXd phi_x = _A_T[0] * _data[0].col(_spatialIndex);
    cell.setMacroscopicMass((_A[0].row(_t) * phi_x).value());
    tarch::la::Vector<dim, double> mo_smooth;
    for (unsigned int d = 0; d < dim; d++) { // (optimized compiler will unroll this loop)
      phi_x = _A_T[d + 1] * _data[d + 1].col(_spatialIndex);
      mo_smooth[d] = (_A[d + 1].row(_t) * phi_x).value();
    }
    cell.setMacroscopicMomentum(mo_smooth);
  }
  _spatialIndex++;
}

template <unsigned int dim> void coupling::noisereduction::POD<dim>::endProcessInnerMacroscopicCells() {
  if (!_firstTraversal) {
    _cycleCounter++;
    _t = _cycleCounter % _timeWindowSize;
  }
  _firstTraversal = !_firstTraversal;
}

// TODO
/*template<unsigned int dim>
void coupling::noisereduction::POD<dim>::
apply(){
        beginProcessInnerMacroscopicCells();
        for(unsigned int i = 0; i < outputCellVector.size(); i++)
processInnerMacroscopicCell(*(_domainCells[i]), i); //TODO: Change POD to use
vector incides, i.e _domainCellIndices[i].
        endProcessInnerMacroscopicCells();
} */

template <unsigned int dim>
unsigned int coupling::noisereduction::POD<dim>::getLocalNumberMacroscopicCells(const coupling::IndexConversion<dim> &indexConversion) const {
  const tarch::la::Vector<dim, unsigned int> localCells(indexConversion.getLocalNumberMacroscopicCells());
  unsigned int num = localCells[0];
  for (unsigned int d = 1; d < dim; d++) {
    num = num * localCells[d];
  }
  return num;
}
