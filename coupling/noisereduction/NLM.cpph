
template<unsigned int dim>
coupling::noisereduction::NLM<dim>::NLM(
  const coupling::IndexConversion<dim> &indexConversion,
  const tarch::utils::MultiMDService<dim>& multiMDService,
  int tws
):
coupling::noisereduction::NoiseReduction<dim>(indexConversion, multiMDService, true),
_timeWindowSize(tws),
_M(2),
_d(1),
_cycleCounter(0),
_t(0),
_firstTraversal(true),
//_flowfield(indexConversion.getLocalNumberMacroscopicCells() + tarch::la::Vector<dim,unsigned int>(2)*_d, tws),
//_patchfield(indexConversion.getLocalNumberMacroscopicCells(), tws)

_flowfield(tarch::la::Vector<dim,unsigned int>(6,6,6), tws),   // TODO
_patchfield(tarch::la::Vector<dim,unsigned int>(4,4,4), tws)

//_flowfield(tarch::la::Vector<dim,unsigned int>(6,6), tws),
//_patchfield(tarch::la::Vector<dim,unsigned int>(4,4), tws)

{

  for(int t = 0; t < tws; t++)
    for(unsigned int x = 0; x<6; x++)
      for(unsigned int y = 0; y<6; y++)
        for(unsigned int z = 0; z<6; z++){
          coupling::noisereduction::Quantities<dim>& q = _flowfield(tarch::la::Vector<3,unsigned int>(x,y,z), t);
          //coupling::noisereduction::Quantities<dim>& q = _flowfield(tarch::la::Vector<2,unsigned int>(x,y), t);
          q[0] = 1;
          q[1] = 0;
          q[2] = 0;
          q[3] = 0;
        }

  /* simple 2D field test (needs access to private members)

  coupling::noisereduction::Flowfield<2> ff(tarch::la::Vector<2,unsigned int>(4,4), 1);
  ff(tarch::la::Vector<2,unsigned int>(0,0), 0) = coupling::noisereduction::Quantities<2>(0.);
  ff(tarch::la::Vector<2,unsigned int>(1,0), 0) = coupling::noisereduction::Quantities<2>(1.);
  ff(tarch::la::Vector<2,unsigned int>(2,0), 0) = coupling::noisereduction::Quantities<2>(2.);
  ff(tarch::la::Vector<2,unsigned int>(3,0), 0) = coupling::noisereduction::Quantities<2>(3.);
  ff(tarch::la::Vector<2,unsigned int>(0,1), 0) = coupling::noisereduction::Quantities<2>(4.);
  ff(tarch::la::Vector<2,unsigned int>(1,1), 0) = coupling::noisereduction::Quantities<2>(5.);
  ff(tarch::la::Vector<2,unsigned int>(2,1), 0) = coupling::noisereduction::Quantities<2>(6.);
  ff(tarch::la::Vector<2,unsigned int>(3,1), 0) = coupling::noisereduction::Quantities<2>(7.);
  ff(tarch::la::Vector<2,unsigned int>(0,2), 0) = coupling::noisereduction::Quantities<2>(8.);
  ff(tarch::la::Vector<2,unsigned int>(1,2), 0) = coupling::noisereduction::Quantities<2>(9.);
  ff(tarch::la::Vector<2,unsigned int>(2,2), 0) = coupling::noisereduction::Quantities<2>(10.);
  ff(tarch::la::Vector<2,unsigned int>(3,2), 0) = coupling::noisereduction::Quantities<2>(11.);
  ff(tarch::la::Vector<2,unsigned int>(0,3), 0) = coupling::noisereduction::Quantities<2>(12.);
  ff(tarch::la::Vector<2,unsigned int>(1,3), 0) = coupling::noisereduction::Quantities<2>(13.);
  ff(tarch::la::Vector<2,unsigned int>(2,3), 0) = coupling::noisereduction::Quantities<2>(14.);
  ff(tarch::la::Vector<2,unsigned int>(3,3), 0) = coupling::noisereduction::Quantities<2>(15.);

  coupling::noisereduction::Patchfield<2> pf(tarch::la::Vector<2,unsigned int>(2,2), 1);
  pf.construct(tarch::la::Vector<2,unsigned int>(0,0),0,
    tarch::la::Vector<2,unsigned int>(3,3), 1, ff, tarch::la::Vector<2,unsigned int>(1,1), 0);
  pf.construct(tarch::la::Vector<2,unsigned int>(1,0),0,
    tarch::la::Vector<2,unsigned int>(3,3), 1, ff, tarch::la::Vector<2,unsigned int>(2,1), 0);
  pf.construct(tarch::la::Vector<2,unsigned int>(0,1),0,
    tarch::la::Vector<2,unsigned int>(3,3), 1, ff, tarch::la::Vector<2,unsigned int>(1,2), 0);
  pf.construct(tarch::la::Vector<2,unsigned int>(1,1),0,
    tarch::la::Vector<2,unsigned int>(3,3), 1, ff, tarch::la::Vector<2,unsigned int>(2,2), 0);

  std::cout << "mass in top left patch at t0: " << std::endl;
  coupling::noisereduction::Patch<2>& p = pf(tarch::la::Vector<2,unsigned int>(0,0),0);
  std::cout << p._flowfield(tarch::la::Vector<2,unsigned int>(0,0),0)[0] << " " << p._flowfield(tarch::la::Vector<2,unsigned int>(1,0),0)[0] << " " << p._flowfield(tarch::la::Vector<2,unsigned int>(2,0),0)[0] << std::endl;
  std::cout << p._flowfield(tarch::la::Vector<2,unsigned int>(0,1),0)[0] << " " << p._flowfield(tarch::la::Vector<2,unsigned int>(1,1),0)[0] << " " << p._flowfield(tarch::la::Vector<2,unsigned int>(2,1),0)[0] << std::endl;
  std::cout << p._flowfield(tarch::la::Vector<2,unsigned int>(0,2),0)[0] << " " << p._flowfield(tarch::la::Vector<2,unsigned int>(1,2),0)[0] << " " << p._flowfield(tarch::la::Vector<2,unsigned int>(2,2),0)[0] << std::endl;

  std::cout << "Means of patches at t0: " << std::endl;
  std::cout << pf(tarch::la::Vector<2,unsigned int>(0,0),0)._localMean << std::endl;
  std::cout << pf(tarch::la::Vector<2,unsigned int>(1,0),0)._localMean << std::endl;
  std::cout << pf(tarch::la::Vector<2,unsigned int>(0,1),0)._localMean << std::endl;
  std::cout << pf(tarch::la::Vector<2,unsigned int>(1,1),0)._localMean << std::endl;

  */
}

template<unsigned int dim>
coupling::noisereduction::NLM<dim>::~NLM(){
  //if (_data!=NULL){ delete [] _data; _data=NULL;}
}

template<unsigned int dim>
void coupling::noisereduction::NLM<dim>::
beginProcessInnerMacroscopicCells(){
}

// TODO
inline unsigned int posmod(int i, int n) {
  return (i % n + n) % n;
}

template<unsigned int dim>
void coupling::noisereduction::NLM<dim>::
processInnerMacroscopicCell(
coupling::datastructures::MacroscopicCell<dim> &cell, const unsigned int &index){
/*
  const double sigsq = 1000;
  const double hsq = 1000;

  tarch::la::Vector<3,unsigned int> idx(coupling::noisereduction::NLM<dim>::_indexConversion.getGlobalVectorCellIndex(index));
  idx += tarch::la::Vector<3,unsigned int>(-4, -4, -4);  // TODO

  if(_firstTraversal){
    // save data
    coupling::noisereduction::Quantities<dim>& q = _flowfield(idx, _t);
    q[0] = cell.getMacroscopicMass();
    q[1] = cell.getMacroscopicMomentum()[0];
    q[2] = cell.getMacroscopicMomentum()[1];
    q[3] = cell.getMacroscopicMomentum()[2];
  }
  else{
    unsigned int t(0);
    // TODO
    if(idx[0] > 0 && idx[0] < 5 && idx[1] > 0 && idx[1] < 5 && idx[2] > 0 && idx[2] < 5){ // denoise here
      coupling::noisereduction::Patch<dim>& me = _patchfield(idx - tarch::la::Vector<3,unsigned int>(1), _t);

      double C = 0;
      coupling::noisereduction::Quantities<dim> res(0);

      int tdist = std::min((int)_timeWindowSize,(int)_cycleCounter+1);

      // TODO restrict loops to bouncing V_i
      for(int offset_t = 0; offset_t > -tdist; offset_t--){
        t = posmod(_t + offset_t, _timeWindowSize);
        for(unsigned int x = 0; x<4; x++)
          for(unsigned int y = 0; y<4; y++)
            for(unsigned int z = 0; z<4; z++){
              coupling::noisereduction::Patch<dim>& other = _patchfield(tarch::la::Vector<3,unsigned int>(x,y,z), t);

              double dist = me.distance(other);

              //std::cout << "dist = " << dist << std::endl;
              double weight = std::exp(-  std::max(dist - sigsq ,0.0) / hsq) * 1/(-offset_t +1);
              //std::cout << "weight = " << weight << std::endl;
              coupling::noisereduction::Quantities<dim>&  q = _flowfield(
                tarch::la::Vector<3,unsigned int>(x,y,z)+tarch::la::Vector<3,unsigned int>(1), t);
              res = res + (q * weight);
              C += weight;
            }
      }
      res = res * (1/C);
      cell.setMacroscopicMass(res[0]);
      cell.setMacroscopicMomentum(tarch::la::Vector<3,double>(res[1],res[2],res[3]));
    }
  }*/
}

template<unsigned int dim>
void coupling::noisereduction::NLM<dim>::
endProcessInnerMacroscopicCells(){

  if(!_firstTraversal){
    _cycleCounter++;
    _t = _cycleCounter%_timeWindowSize;
  }
  else{/*
    for(unsigned int x = 0; x<4; x++)
      for(unsigned int y = 0; y<4; y++)
        for(unsigned int z = 0; z<4; z++){
          tarch::la::Vector<3,unsigned int> pos(x,y,z);
          if(_cycleCounter > _t) _patchfield.destroy(pos,_t);
          _patchfield.construct(pos,_t,
            tarch::la::Vector<3,unsigned int>(3,3,3), 3, _flowfield, pos + tarch::la::Vector<3,unsigned int>(1), _t);
        }*/
  }
  _firstTraversal = !_firstTraversal;
}

template<unsigned int dim>
void coupling::noisereduction::NLM<dim>::
processOuterMacroscopicCell(
      coupling::datastructures::MacroscopicCell<dim> &cell, const unsigned int &index
    ){
  if(_firstTraversal){
    // save data
    //_data[_t*_spatialSize + index]._mass = cell.getMacroscopicMass();
    //_data[_t*_spatialSize + index]._momentum = cell.getMacroscopicMomentum();
  }
}

template<unsigned int dim>
void coupling::noisereduction::NLM<dim>::
beginProcessOuterMacroscopicCells(){

}

    template<unsigned int dim>
void coupling::noisereduction::NLM<dim>::
endProcessOuterMacroscopicCells(){
  /*if(_firstTraversal)
   // todo compute here _localMean and _localStandardDeviation
   // for all cells for this _t
  */
  /*if(!_firstTraversal){
    _cycleCounter++;
    _t = _cycleCounter%_timeWindowSize;
  }
  _firstTraversal = !_firstTraversal;*/
}
