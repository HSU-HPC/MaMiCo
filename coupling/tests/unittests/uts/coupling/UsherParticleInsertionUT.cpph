#pragma once

#include "coupling/UsherParticleInsertion.h"
#include "coupling/tests/unittests/UnitTestInterface.h"
#include "coupling/tests/unittests/MockService.cpph"
#include "coupling/tests/unittests/UnitTestingService.h"

#include "tarch/configuration/ParseConfiguration.h"
#include "coupling/configurations/MaMiCoConfiguration.h"
#include "coupling/configurations/BoundaryForceConfiguration.h"


//TODO: move these to namespace? -> general overhaul of namespacing??

//Arbitrary temperature and veclocityvalue to give during testing of insertDeleteMass. i
//This should not matter for our testing purposes, as we won't run any further steps after inserting.
inline const double USHER_UT_INSERTION_TEMPERATURE = 0.0;
template<unsigned int dim>
inline const tarch::la::Vector<dim,double> USHER_UT_INSERTION_VELOCITY = tarch::la::Vector<dim,double>(0.0);

//Location of the LinkedCells from MDSolverInterface we use to construct our dummy MacroCells.
//Used in MDSolverInterface::getLinkedCell
template<unsigned int dim>
inline const tarch::la::Vector<dim, unsigned int> USHER_UT_LINKEDCELL_INDEX_FROM_MACROCELLS = tarch::la::Vector<dim,unsigned int>(0);

//Location of where to insert LinkedCells from MDSolverInterface into our dummy MacroCells.
//Used in MacroscopicCellWithLinkedCells::addLinkedCell
inline const unsigned int USHER_UT_LINKEDCELL_INDEX_TO_MACROCELLS = 0;

namespace coupling {
	template<class LinkedCell, unsigned int dim>
	class UsherParticleInsertionUT;
}


//note: this has only been tested with LinkedCell=MY_LINKEDCELL and dim=3
template<class LinkedCell,unsigned int dim>
class coupling::UsherParticleInsertionUT : public testing::ut::UnitTestImpl<coupling::UsherParticleInsertion<LinkedCell,dim>> {
	public:

		//Used when testing Usher's most important function: insertDeleteMass
		struct insertDeleteParametrisation {

			//all of these cells are going to be inserted, one by one...
			std::vector<coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> *> macroCellsWithLinkedCells;

			//...while all of the following are constant per testing instance.
			const tarch::la::Vector<dim,double>& macroscopicCellPosition;
			const tarch::la::Vector<dim,double>& macroscopicCellSize;
			const tarch::la::Vector<dim,double>& meanVelocity;
			const double& temperature;
			const coupling::BoundaryForceController<LinkedCell,dim>& boundaryForceController;
		};
		
		UsherParticleInsertionUT(testing::ut::UnitTestingService *uts):
		testing::ut::UnitTestImpl<coupling::UsherParticleInsertion<LinkedCell,dim>>(uts->getRank(), uts->getCommSize())
		{
			//Generate vector containing mocks of coupling::UsherParticleInsertion<LinkedCell,dim>
			//Also generate insertDeleteParametrisation for each mock.
			std::vector<coupling::UsherParticleInsertion<LinkedCell,dim> *> this_mocks;
			for(unsigned int i = 0; i < uts->getMDInterfaces().size() /* == uts->getIndexConversions.size()*/; i++) {
				
				auto mdInterface = uts->getMDInterfaces()[i];
				auto indexConversion = uts->getIndexConversions()[i];
				auto mamicoConfig = uts->getMamicoConfigs()[i];

				//Get MacroscopicCell size from mamico config
				tarch::la::Vector<dim,double> macroscopicCellSize = mamicoConfig->getMacroscopicCellConfiguration().getMacroscopicCellSize();
				//Get number of LinkedCells per MacroscopicCell from mamico config
				tarch::la::Vector<dim,unsigned int> linkedCellsPerMacroscopicCell = mamicoConfig->getMacroscopicCellConfiguration().getNumberLinkedCellsPerMacroscopicCell();
				//Derive MacroscopicCell block size from that.
				tarch::la::Vector<dim,unsigned int> blockSize = linkedCellsPerMacroscopicCell;

				//Get some linked cells from md interface. we always take the first (i.e 0..0) LinkedCell per MacroCell in MD domain.
				std::vector<LinkedCell *> linkedCellsFromMD = {};
				//We need to convert this to linear to iterate over all cells, independant of dim
				//Since each of the MD instances runs sequentially, local == global.
				unsigned int linearGlobalNumberMacroscopicCells = indexConversion->getGlobalCellIndex(indexConversion->getGlobalNumberMacroscopicCells());
				for(unsigned int cell_index = 0; cell_index < linearGlobalNumberMacroscopicCells; cell_index++) {
					//...and now we convert the index back to a vector.
					auto vectorCell_index = indexConversion->getGlobalVectorCellIndex(cell_index);

					//exclude cells in ghost layer
					bool gl = false;
					for(unsigned int d = 0; d<dim; d++) if(vectorCell_index[d] == 0) gl = true;
					if(gl) { /*std::cout <<  "SKIP" << std::endl;*/ continue; }


					//Fill list of LinkedCells
					linkedCellsFromMD.push_back(&(mdInterface->getLinkedCell(
						vectorCell_index,																			//macroscopicCellIndex
						tarch::la::Vector<dim,unsigned int>(USHER_UT_LINKEDCELL_INDEX_FROM_MACROCELLS<dim>),		//linkedCellInMacroscopicCell
						linkedCellsPerMacroscopicCell,																//linkedCellsPerMacroscopicCell
						*indexConversion																			//indexConversion
					)));
					//std::cout << "ADDED CELL" << std::endl;
				}

				//Construct MacroscopicCellWithLinkedCells for each of these LinkedCells
				std::vector<coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> *> macroCellsWithLinkedCells = {};
				for(LinkedCell* linkedCell : linkedCellsFromMD) {
					//Construct new MacroscopicCellWithLinkedCells
					auto newMacroCell = new coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim>(blockSize);
					newMacroCell->addLinkedCell(*linkedCell, USHER_UT_LINKEDCELL_INDEX_TO_MACROCELLS);
					macroCellsWithLinkedCells.push_back(newMacroCell);
				}
				
				//Generate insertDeleteParametrisation struct
				_insertDeleteParametrisations.push_back({
					macroCellsWithLinkedCells,
					tarch::la::Vector<dim,double>(0), //Currently, we always insert at the exact same location. Future TODO
					macroscopicCellSize,
					USHER_UT_INSERTION_VELOCITY<dim>,
					USHER_UT_INSERTION_TEMPERATURE,
					*(mamicoConfig->getBoundaryForceConfiguration().interpreteConfiguration(mdInterface))
				});

				auto newParticleInsertion = mamicoConfig->getParticleInsertionConfiguration().interpreteConfiguration(mdInterface);
				//Check if this new ParticleInsertion is in fact USHER
				if (dynamic_cast<coupling::UsherParticleInsertion<LinkedCell,dim> *>(newParticleInsertion) != nullptr)
					this_mocks.push_back(static_cast<coupling::UsherParticleInsertion<LinkedCell,dim> *>(newParticleInsertion));
				else throw std::runtime_error("ERROR: Trying to add non-USHER Particle Insertion to mock list for USHER Unit Test!");
			}

			//Create new MockService for coupling::UsherParticleInsertion<LinkedCell,dim> using mocks generated above:
			this->_mockService = uts->addMockService<coupling::UsherParticleInsertion<LinkedCell,dim>>(this_mocks);
			
			//Add test functions
			this->_testFuncs.push_back(std::make_tuple(new 
				std::function<void (coupling::UsherParticleInsertion<LinkedCell,dim>&)>
				{ [this] (coupling::UsherParticleInsertion<LinkedCell,dim>& mock) { testInsertDeleteMass(mock); } }, "insertDeleteMass"
			));
		}

		~UsherParticleInsertionUT() {
			//We allocted this in constructor. Note that the std::function allocations get freed automatically by the interface.
			for(auto parametrisation : _insertDeleteParametrisations)
				for(auto cellPtr : parametrisation.macroCellsWithLinkedCells) 
					delete cellPtr;
		}

		//Test if all mock cells can be inserted without throwing
		void testInsertDeleteMass(coupling::UsherParticleInsertion<LinkedCell,dim>& mock) {
			for(auto parametrisation : _insertDeleteParametrisations) {
				for(auto cell : parametrisation.macroCellsWithLinkedCells) {
					try {
						mock.insertDeleteMass(
							*cell,
							parametrisation.macroscopicCellPosition,
							parametrisation.macroscopicCellSize,
							parametrisation.meanVelocity,
							parametrisation.temperature,
							parametrisation.boundaryForceController
						);
						//TODO: some fancy debug output
					}
					catch (std::runtime_error& e) {
						throw std::runtime_error(std::string("insertDeleteMass threw exception: ").append(e.what()));
					}
				}
			}
		}

	private:
		//The nth entry in this vector corresponds to the nth MD Interface returned by uts->getMDInterfaces
		std::vector</*coupling::UsherParticleInsertionUT::*/insertDeleteParametrisation> _insertDeleteParametrisations;
};

