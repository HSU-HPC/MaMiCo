#pragma once

#include "coupling/paralleltopology/XYZTopology.h"
#include "coupling/tests/unittests/UnitTestInterface.h"
#include "coupling/tests/unittests/MockService.cpph"
#include "coupling/tests/unittests/UnitTestingService.h"

namespace coupling { namespace paralleltopology {
	template<unsigned int dim>
	class XYZTopologyUT;
}}


template<unsigned int dim>
class coupling::paralleltopology::XYZTopologyUT : public testing::ut::UnitTestImpl<coupling::paralleltopology::XYZTopology<dim>> {
	public:
		XYZTopologyUT(testing::ut::UnitTestingService *uts):
		testing::ut::UnitTestImpl<coupling::paralleltopology::XYZTopology<dim>>(uts->getRank(), uts->getCommSize())
		{
			//Get mock services of all constructor parameters (i.e. Vector<dim,unsigned int> & unsigned int)
			if(uts->getMockService<tarch::la::Vector<dim,unsigned int>>())
				 _vectorMS = uts->getMockService<tarch::la::Vector<dim,unsigned int>>().value();
			else ;//TODO: error
			if(uts->getMockService<unsigned int>())
				 _uintMS = uts->getMockService<unsigned int>().value();
			else ;//TODO: error

			//Restrict what mocks of these two classes to use using two lambda expressions (c.f. implementation of MockService):
			auto vector_allLessThanThree_predicate = [] (tarch::la::Vector<dim,unsigned int> v) { 
														for(unsigned int i = 0; i < dim; i++) if(v[i] > 3) return false;
														return true;
													};
			auto uint_lessThanFive_predicate = [] (unsigned int u) { return u < 10; };

			std::vector<tarch::la::Vector<dim,unsigned int>> vectorMocks 
				= _vectorMS->getMocksCopy<tarch::la::Vector<dim,unsigned int>>({}, vector_allLessThanThree_predicate);
			std::vector<unsigned int> offsetMocks
				= _uintMS->getMocksCopy<unsigned int>({}, uint_lessThanFive_predicate);
			
			std::vector<coupling::paralleltopology::XYZTopology<dim> *> thisMocks = {}; //filled below

			for(auto vector : vectorMocks) for(auto offset : offsetMocks)
				thisMocks.push_back(new coupling::paralleltopology::XYZTopology<dim>(vector, offset));

			this->_mockService = uts->addMockService<coupling::paralleltopology::XYZTopology<dim>>(thisMocks);
			
			//Add test functions to UTI::_testFuncs
			this->_testFuncs.push_back(std::make_tuple(new 
				std::function<void (coupling::paralleltopology::XYZTopology<dim>&)>
				{ [this] (coupling::paralleltopology::XYZTopology<dim>& mock) { test_getProcessCoordinates(mock); } }, "getProcessCoordinates"
			));
			this->_testFuncs.push_back(std::make_tuple(new 
				std::function<void (coupling::paralleltopology::XYZTopology<dim>&)>
				{ [this] (coupling::paralleltopology::XYZTopology<dim>& mock) { test_getRank(mock); } }, "getRank"
			));
		}

		//TODO: implement actual assertions
		void test_getProcessCoordinates(coupling::paralleltopology::XYZTopology<dim> mock) { return; }
		void test_getRank(coupling::paralleltopology::XYZTopology<dim> mock) { return; }
	private:
		 testing::ut::MockService* _vectorMS;
		 testing::ut::MockService* _uintMS;
};
