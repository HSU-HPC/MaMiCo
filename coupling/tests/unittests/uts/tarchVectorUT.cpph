#pragma once

#include <iostream>

#include "tarch/la/Vector.h"
#include "coupling/tests/unittests/UnitTestInterface.h"
#include "coupling/tests/unittests/MockService.cpph"
#include "coupling/tests/unittests/UnitTestingService.h"

#define DEBUG_UT_VECTOR


//Maybe namespace "testing::ut::[...]"?
namespace tarch { namespace la {
	template<int size, class T>
	class VectorUT;
}}


template<int size, class T> 
class tarch::la::VectorUT : public testing::ut::UnitTestInterface {
	public:
		VectorUT(testing::ut::UnitTestingService *uts):
		testing::ut::UnitTestInterface(typeid(this).name())
		{
			//Request MockService of T
			if(uts->getMockService<T>().has_value()) _TMS = uts->getMockService<T>().value();
			else exit(EXIT_FAILURE); //TODO: EXCEPTION

			//Initialize Mocks of this
			std::vector<tarch::la::Vector<size, T> *> tarchlavectorMocks;
			for(auto Tmock : _TMS->getMocksCopy<T>())
				tarchlavectorMocks.push_back(new tarch::la::Vector<size, T>(Tmock));

			//Create new MockService for this using dummy values generated above
			testing::ut::UnitTestInterface::_thisMs = uts->addMockService<tarch::la::Vector<size, T>>(tarchlavectorMocks);

			#ifdef DEBUG_UT_VECTOR
				std::cout << testing::ut::UnitTestInterface::PRINT_PREFIX() << "Finished generating mocks " << std::endl;
			#endif
			
			//Add test functions to UTI::_testFuncs
			testing::ut::UnitTestInterface::_testFuncs.push_back(new std::function<void ()>
				{ [this] () { testVectorAddition(); } }
			);
			testing::ut::UnitTestInterface::_testFuncs.push_back(new std::function<void ()>
				{ [this] () { testTrivialSuccess(); } }
			);
			testing::ut::UnitTestInterface::_testFuncs.push_back(new std::function<void ()>
				{ [this] () { testTrivialFailure(); } }
			);


		}
		
		~VectorUT() {}	

		//Verify correctness of operator+=
		void testVectorAddition() {
			for(auto vector1 : testing::ut::UnitTestInterface::_thisMs->getMocksCopy<tarch::la::Vector<size, T>>()) {
				for(auto vector2 : testing::ut::UnitTestInterface::_thisMs->getMocksCopy<tarch::la::Vector<size, T>>()) {
					auto addedVector = vector1;
					addedVector += vector2;
						#if 0//def DEBUG_UT_VECTOR
							std::cout 
							<< " vector1: " << vector1
							<< ", vector2: " << vector2
							<< ", addedVector: " << addedVector << std::endl;
						#endif
						
					for(int i = 0; i < size; i++){
						if(addedVector[i] != vector1[i] + vector2[i]) { 								
							throw(std::runtime_error("\x1B[41m failure of testVectorAddition \x1B[0m"));
						}
					}
				}
			}
			#ifdef DEBUG_UT_VECTOR
				std::cout << testing::ut::UnitTestInterface::PRINT_PREFIX() << "testVectorAddition: \x1B[032m Success! \x1B[0m" << std::endl;
			#endif
		}

		//TODO: remove dummy tests
		void testTrivialSuccess() {
			std::cout << testing::ut::UnitTestInterface::PRINT_PREFIX() << "testTrivialSuccess: \x1B[032m Success! \x1B[0m" << std::endl;
		}
		void testTrivialFailure() {
			throw(std::runtime_error("\x1B[41m trivial failure test failed \x1B[0m"));
		}

		
		
	private:
		//Used mock service of class T
		testing::ut::MockService* _TMS;
};
