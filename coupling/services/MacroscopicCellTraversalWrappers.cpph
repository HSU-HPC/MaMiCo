// Copyright (C) 2015 Technische Universitaet Muenchen
// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico
#ifndef _MOLECULARDYNAMICS_COUPLING_MACROSCOPICCELLTRAVERSALWRAPPERS_H_
#define _MOLECULARDYNAMICS_COUPLING_MACROSCOPICCELLTRAVERSALWRAPPERS_H_

/** the following wrappers and smaller functional classes are included in the MacroscopicCellServiceImpl for internal use
 *  in this class only. They are used together with the applyTo...() methods of MacroscopicCells to bring
 *  functionality which is defined cellwise onto the grid of macroscopic cells.
 *  @author Philipp Neumann
 */




/** wrapper to carry out functionality on a single macroscopic cell. This function can be called on several macroscopic cells
 *  using the callback patterns of MacroscopicCells.
 *  In the following, several wrappers are provided for the TransferStrategy as well as some further functional stuff which
 *  is required from the MacroscopicCellServiceImpl.
 */
class Wrapper {
  public:
    Wrapper(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): _thisPtr(thisPtr){}
    virtual ~Wrapper(){}
    virtual void beginCellIteration()=0;
    virtual void endCellIteration()=0;
    virtual void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index)=0;
  protected:
    coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim>* _thisPtr;
};


/** wrapper for method processInnerMacroscopicCellBeforeReceivingMacroscopicSolverData of TransferStrategy */
class Wrapper4ProcessInnerMacroscopicCellBeforeReceivingMacroscopicSolverData: public Wrapper {
  public:
    Wrapper4ProcessInnerMacroscopicCellBeforeReceivingMacroscopicSolverData(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

    void beginCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->beginProcessInnerMacroscopicCellsBeforeReceivingMacroscopicSolverData();
    }
    void endCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->endProcessInnerMacroscopicCellsBeforeReceivingMacroscopicSolverData();
    }
    void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
      Wrapper::_thisPtr->_transferStrategy->processInnerMacroscopicCellBeforeReceivingMacroscopicSolverData(cell,index);
    }
};



/** wrapper for method processOuterMacroscopicCellBeforeReceivingMacroscopicSolverData of TransferStrategy */
class Wrapper4ProcessOuterMacroscopicCellBeforeReceivingMacroscopicSolverData: public Wrapper {
  public:
    Wrapper4ProcessOuterMacroscopicCellBeforeReceivingMacroscopicSolverData(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

    void beginCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->beginProcessOuterMacroscopicCellsBeforeReceivingMacroscopicSolverData();
    }
    void endCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->endProcessOuterMacroscopicCellsBeforeReceivingMacroscopicSolverData();
    }

    void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
      Wrapper::_thisPtr->_transferStrategy->processOuterMacroscopicCellBeforeReceivingMacroscopicSolverData(cell,index);
    }
};



/** wrapper for method processInnerMacroscopicCellAfterReceivingMacroscopicSolverData of TransferStrategy */
class Wrapper4ProcessInnerMacroscopicCellAfterReceivingMacroscopicSolverData: public Wrapper {
  public:
    Wrapper4ProcessInnerMacroscopicCellAfterReceivingMacroscopicSolverData(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

    void beginCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->beginProcessInnerMacroscopicCellsAfterReceivingMacroscopicSolverData();
    }
    void endCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->endProcessInnerMacroscopicCellsAfterReceivingMacroscopicSolverData();
    }
    void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
      Wrapper::_thisPtr->_transferStrategy->processInnerMacroscopicCellAfterReceivingMacroscopicSolverData(cell,index);
    }
};



/** wrapper for method processOuterMacroscopicCellAfterReceivingMacroscopicSolverData of TransferStrategy */
class Wrapper4ProcessOuterMacroscopicCellAfterReceivingMacroscopicSolverData: public Wrapper {
  public:
    Wrapper4ProcessOuterMacroscopicCellAfterReceivingMacroscopicSolverData(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

    void beginCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->beginProcessOuterMacroscopicCellsAfterReceivingMacroscopicSolverData();
    }
    void endCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->endProcessOuterMacroscopicCellsAfterReceivingMacroscopicSolverData();
    }
    void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
      Wrapper::_thisPtr->_transferStrategy->processOuterMacroscopicCellAfterReceivingMacroscopicSolverData(cell,index);
    }
};



/** wrapper for method processInnerMacroscopicCellBeforeSendingMDSolverData of TransferStrategy */
class Wrapper4ProcessInnerMacroscopicCellBeforeSendingMDSolverData: public Wrapper {
  public:
    Wrapper4ProcessInnerMacroscopicCellBeforeSendingMDSolverData(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

    void beginCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->beginProcessInnerMacroscopicCellsBeforeSendingMDSolverData();
    }
    void endCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->endProcessInnerMacroscopicCellsBeforeSendingMDSolverData();
    }
    void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
      Wrapper::_thisPtr->_transferStrategy->processInnerMacroscopicCellBeforeSendingMDSolverData(cell,index);
    }
};



/** wrapper for method processOuterMacroscopicCellBeforeSendingMDSolverData of TransferStrategy */
class Wrapper4ProcessOuterMacroscopicCellBeforeSendingMDSolverData: public Wrapper {
  public:
    Wrapper4ProcessOuterMacroscopicCellBeforeSendingMDSolverData(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

    void beginCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->beginProcessOuterMacroscopicCellsBeforeSendingMDSolverData();
    }
    void endCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->endProcessOuterMacroscopicCellsBeforeSendingMDSolverData();
    }
    void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
      Wrapper::_thisPtr->_transferStrategy->processOuterMacroscopicCellBeforeSendingMDSolverData(cell,index);
    }
};


/** wrapper for method processInnerMacroscopicCellAfterMDTimestep of TransferStrategy */
class Wrapper4ProcessInnerMacroscopicCellAfterMDTimestep: public Wrapper {
  public:
    Wrapper4ProcessInnerMacroscopicCellAfterMDTimestep(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

    void beginCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->beginProcessInnerMacroscopicCellsAfterMDTimestep();
    }
    void endCellIteration(){
      Wrapper::_thisPtr->_transferStrategy->endProcessInnerMacroscopicCellsAfterMDTimestep();
    }
    void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
      Wrapper::_thisPtr->_transferStrategy->processInnerMacroscopicCellAfterMDTimestep(cell,index);
    }
};


/** computes and stores the current velocity in each non-ghost macroscopic cell. */
class Wrapper4ComputeAndSetCurrentVelocity: public Wrapper {
public:
  Wrapper4ComputeAndSetCurrentVelocity(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

  void beginCellIteration(){}
  void endCellIteration(){}
  void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
    coupling::cellmappings::ComputeMomentumMapping<LinkedCell,dim> computeMomentumMapping(Wrapper::_thisPtr->_mdSolverInterface);
    cell.iterateConstCells(computeMomentumMapping);
    const tarch::la::Vector<dim,double> velocity = computeMomentumMapping.getMeanVelocity();
    cell.setCurrentVelocity(velocity);
  }
};

/** computes and stores the current velocity in each non-ghost macroscopic cell. */
class Wrapper4ApplyVacuumAndSetAccordingMasses: public Wrapper {
public:
  Wrapper4ApplyVacuumAndSetAccordingMasses(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

  void beginCellIteration(){}
  void endCellIteration(){}
  void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
    coupling::cellmappings::ComputeMassMapping<LinkedCell,dim> computeMassMapping(Wrapper::_thisPtr->_mdSolverInterface);
    cell.iterateConstCells(computeMassMapping);
    unsigned int numberOfParticles = computeMassMapping.getNumberOfParticles();
    while(numberOfParticles > 0){
      coupling::cellmappings::DeleteParticleMapping<LinkedCell,dim> deleteParticleMapping(numberOfParticles-1,Wrapper::_thisPtr->_mdSolverInterface);
      cell.iterateCells(deleteParticleMapping);
      numberOfParticles--;

      // compute mean potential energy over all macroscopic cells and set the value in the macroscopic cell
      coupling::cellmappings::ComputeMeanPotentialEnergyMapping<LinkedCell,dim> computeMeanPotentialEnergyMapping(Wrapper::_thisPtr->_mdSolverInterface, *Wrapper::_thisPtr->_boundaryForceController);
      // macroscopic cell access
      coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> * const macroscopicCells = Wrapper::_thisPtr->_macroscopicCells.getMacroscopicCellsWithLinkedCells();
      // buffers for temperature,momentum,mean velocity,pot. energy
      double temperature(0.0);
      tarch::la::Vector<dim,double> momentum(0.0);
      tarch::la::Vector<dim,double> meanVelocity(0.0);
      double potentialEnergy = 0.0;
      // buffer for insertion/deletion action that has been carried out
      // typename coupling::ParticleInsertion<LinkedCell,dim>::Action particleInsertionAction;
      // true, if the costly operation of contructing the energy landscape is really required
      bool constructEnergyLandscape;

      // variables for internal looping --------------------------
      // cellIndex used as loop counter
      tarch::la::Vector<3,unsigned int> cellIndex(1);

      // we have to at least carry out the construction of the energy landscape once for each sub-domain (since we do not know a priori if we need
      // to insert particles or not)
      constructEnergyLandscape = true;
      // reduce size of usherCellStart-vector to be consistent with MDSolverInterface
      const tarch::la::Vector<dim,unsigned int> usherCellStart = coupling::initDimVector<dim>(Wrapper::_thisPtr->_usherCellStart[0]);

      // setup potential energy landscape (i.e. computes the potential energy for all relevant molecules;
      // here, we need to sweep over all molecules contained in the macroscopic cells of interest and
      // compute their current potential energy).
      // Only carry out this costly operation, if there have been modifications to the MD system OR this is the first consideration of
      // this sub-domain. Besides, we skip this operation if the particle insertion does not require it (e.g. in case of rarefied gases,
      // we possibly can come up with something better than USHER)
      if ( constructEnergyLandscape && Wrapper::_thisPtr->_particleInsertion->requiresPotentialEnergyLandscape() ){
        Wrapper::_thisPtr->_mdSolverInterface->setupPotentialEnergyLandscape(usherCellStart,Wrapper::_thisPtr->_usherRange[0],Wrapper::_thisPtr->_numberLinkedCellsPerMacroscopicCell);
        // reset flag
        constructEnergyLandscape = false;
      }

      // determine macroscopic cell index
      const unsigned int index = Wrapper::_thisPtr->_indexConversion->getLocalCellIndex(coupling::initDimVector<dim>(cellIndex));
      // compute cell position
      tarch::la::Vector<dim,double> macroscopicCellPosition(0);
      for (unsigned int d = 0; d < dim; d++){
        macroscopicCellPosition[d] = 0;//Wrapper::_thisPtr->_indexConversion->getMacroscopicCellSize()[d]*cellIndex[d];
      }
      // compute current momentum and energy
      Wrapper::_thisPtr->_momentumController.computeMomentumAndMeanVelocity(macroscopicCells[index],momentum,meanVelocity);
      temperature = Wrapper::_thisPtr->_kineticEnergyController.computeTemperature(macroscopicCells[index]);
      // compute potential energy for this macroscopic cell and store it
      macroscopicCells[index].iterateConstCells(computeMeanPotentialEnergyMapping);
      potentialEnergy = computeMeanPotentialEnergyMapping.getPotentialEnergy();
      macroscopicCells[index].setPotentialEnergy(potentialEnergy);
      Wrapper::_thisPtr->_particleInsertion->insertParticle(
                                  macroscopicCells[index], macroscopicCellPosition,
                                  Wrapper::_thisPtr->_indexConversion->getMacroscopicCellSize(),
                                  meanVelocity, temperature, *Wrapper::_thisPtr->_boundaryForceController);
    }
    // cell.iterateConstCells(computeMassMapping);
    // numberOfParticles = computeMassMapping.getNumberOfParticles();
  }
};

/** calls the MomentumInsertion-mechanisms on each non-ghost macroscopic cell, including the energy controller */
class Wrapper4DistributeMomentum: public Wrapper {
public:
  Wrapper4DistributeMomentum(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr,unsigned int t): Wrapper(thisPtr){}

  void beginCellIteration(){
  }
  void endCellIteration(){}
  void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
    const double temperature = Wrapper::_thisPtr->_kineticEnergyController.computeTemperature(cell);
    Wrapper::_thisPtr->_momentumInsertion->insertMomentum(cell,index);
    Wrapper::_thisPtr->_kineticEnergyController.setTemperature(cell,temperature);
  }
};



/** computes and stores the temperature value in all non-ghost cells. If the temperature parameter is set to -1.0,
 *  the current temperature of the molecules in this cell is stored.
 *  Otherwise, the temperature variable is used and applied to the molecules using the thermostat of the KineticEnergyController.
 */
class Wrapper4ComputeAndStoreTemperature: public Wrapper {
public:
  Wrapper4ComputeAndStoreTemperature(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr,double temperature): Wrapper(thisPtr), _temperature(temperature){}

  void beginCellIteration(){}
  void endCellIteration(){}
  void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
    // if this value is -1.0, we just set the temperature in the cell according to current temperature...
    if (_temperature==-1.0){
      const double myTemperature = Wrapper::_thisPtr->_kineticEnergyController.computeTemperature(cell);
      cell.setTemperature(myTemperature);
    // otherwise we use the temperature value of _setTemperature
    } else {
      cell.setTemperature(_temperature);
      Wrapper::_thisPtr->_kineticEnergyController.setTemperature(cell,_temperature);
    }
  }

private:
  const double _temperature;
};


/** applies the thermostat in all non-ghost cells */
class Wrapper4ApplyTemperature: public Wrapper {
public:
  Wrapper4ApplyTemperature(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

  void beginCellIteration(){}
  void endCellIteration(){}
  void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
      const double temperature = cell.getTemperature();
      Wrapper::_thisPtr->_kineticEnergyController.setTemperature(cell,temperature);
  }
};


/** applies the boundary force in all non-ghost cells which are close to an open boundary */
class Wrapper4ApplyBoundaryForce: public Wrapper {
public:
  Wrapper4ApplyBoundaryForce(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr){}

  void beginCellIteration(){}
  void endCellIteration(){}
  void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
      Wrapper::_thisPtr->_boundaryForceController->applyBoundaryForce(cell,index);
  }
};

class Wrapper4SampleDataInZ: public Wrapper {
public:
  Wrapper4SampleDataInZ(coupling::services::MacroscopicCellServiceImpl<LinkedCell,dim> *thisPtr): Wrapper(thisPtr),
  _velocity(new tarch::la::Vector<dim,double> [1680]), _density(new double [1680]), _temperature(new double [1680]),
  _datacount(new unsigned int [1680]){}

  void beginCellIteration(){}
  void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
    coupling::interface::MoleculeIterator<LinkedCell,dim> *it = Wrapper::_thisPtr->_mdSolverInterface->getMoleculeIterator(cell);
    it->begin();
    while(it->continueIteration()){
      const coupling::interface::Molecule<dim> &wrapper(it->getConst());
      const int posZ = wrapper.getPosition()[2];
      _velocity[posZ] += wrapper.getVelocity();
      _datacountTmp[posZ]++;

      it->next();
    }
    delete it;
  }
  void postprocess(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
    coupling::interface::MoleculeIterator<LinkedCell,dim> *it = Wrapper::_thisPtr->_mdSolverInterface->getMoleculeIterator(cell);
    it->begin();
    while(it->continueIteration()){
      const coupling::interface::Molecule<dim> &wrapper(it->getConst());
      const int posZ = wrapper.getPosition()[2];
      _temperature += tarch::la::dot((wrapper.getVelocity() - _velocityTmp[posZ]),(wrapper.getVelocity() - _velocityTmp[posZ]));

      it->next();
    }
    delete it;
  }
  void endCellIteration(){}
  void endIteration(){
    for(unsigned int i=0; i<_numberBins;i++){
      _velocityTmp=0;
      _densityTmp=0;
      _datacountTmp=0;
    }

  }

private:
  tarch::la::Vector<dim,double> * _velocity;
  tarch::la::Vector<dim,double> * _velocityTmp;
  double * _density;
  double * _densityTmp;
  double * _temperature;
  double * _temperatureTmp;
  unsigned int * _datacount;
  unsigned int * _datacountTmp;
  const unsigned int _numberBins{1680};

};
#endif // _MOLECULARDYNAMICS_COUPLING_MACROSCOPICCELLTRAVERSALWRAPPERS_H_
