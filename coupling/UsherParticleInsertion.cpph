// Copyright (C) 2015 Technische Universitaet Muenchen
// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico

template<class LinkedCell,unsigned int dim>
coupling::UsherParticleInsertion<LinkedCell,dim>::UsherParticleInsertion(
unsigned int insertDeleteMassEveryTimestep,
double rSigmaCoeff, double meanPotentialEnergyFactor,double uOverlapCoeff,
double stepRefCoeff,unsigned int iterMax,unsigned int restartMax,double tolerance,double offsetFromOuterBoundary,
coupling::interface::MDSolverInterface<LinkedCell,dim> * const mdSolverInterface
): coupling::ParticleInsertion<LinkedCell,dim>(insertDeleteMassEveryTimestep),
#ifdef USHER_DEBUG
_energyInserted(0),
_energyRemoved(0),
_ZhouEnergyInserted(0),
_ZhouEnergyRemoved(0),
_particlesInserted(0),
_particlesRemoved(0),
#endif
_mdSolverInterface(mdSolverInterface),
_usherParams(rSigmaCoeff,meanPotentialEnergyFactor,uOverlapCoeff,stepRefCoeff,iterMax,restartMax,tolerance,offsetFromOuterBoundary){}



template<class LinkedCell,unsigned int dim>
typename coupling::ParticleInsertion<LinkedCell,dim>::Action
coupling::UsherParticleInsertion<LinkedCell,dim>::insertDeleteMass(
coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim>& cell,
const tarch::la::Vector<dim,double>& macroscopicCellPosition,
const tarch::la::Vector<dim,double>& macroscopicCellSize,
const tarch::la::Vector<dim,double>& meanVelocity,
const double &temperature,
const coupling::BoundaryForceController<LinkedCell,dim>& boundaryForceController
)  {
  typename coupling::ParticleInsertion<LinkedCell,dim>::Action action = coupling::ParticleInsertion<LinkedCell,dim>::NoAction;
  const double moleculeMass(_mdSolverInterface->getMoleculeMass());
  // if we have enough mass left in the cell, try to insert a particle and remove one particle mass
  if (cell.getMicroscopicMass() >= 0.6*moleculeMass){
    action = insertParticle(cell,macroscopicCellPosition,macroscopicCellSize,meanVelocity,temperature,boundaryForceController);
    if (action == coupling::ParticleInsertion<LinkedCell,dim>::Insertion){
      cell.addMicroscopicMass(-moleculeMass);
    }
  // if we need to delete a particle, we try this and - in case it works - add a particle mass to the negative buffer
} else if (cell.getMicroscopicMass() <= -0.6*moleculeMass){
    action = deleteParticle(cell,boundaryForceController);
    if (action == coupling::ParticleInsertion<LinkedCell,dim>::Deletion){
      cell.addMicroscopicMass(moleculeMass);
      #if (COUPLING_MD_DEBUG==COUPLING_MD_YES)
      std::cout << "Delete particle: Success" << std::endl;
      #endif
    }
  }

  return action;
}


template<class LinkedCell,unsigned int dim>
typename coupling::ParticleInsertion<LinkedCell,dim>::Action
coupling::UsherParticleInsertion<LinkedCell,dim>::insertParticle(
  coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim>& cell,
  const tarch::la::Vector<dim,double>& macroscopicCellPosition,
  const tarch::la::Vector<dim,double>& macroscopicCellSize,
  const tarch::la::Vector<dim,double>& meanVelocity,
  const double &temperature,
  const coupling::BoundaryForceController<LinkedCell,dim>& boundaryForceController
)  {
  coupling::datastructures::Molecule<dim> molecule;

  const typename coupling::ParticleInsertion<LinkedCell,dim>::Action action
  = findParticlePosition(cell,macroscopicCellPosition,macroscopicCellSize,molecule,boundaryForceController);

  // if insertion was successful, initialise velocity according to temperature in macroscopic cell
  if (action == coupling::ParticleInsertion<LinkedCell,dim>::Insertion){
    // initialise velocity of molecule
    tarch::la::Vector<dim,double> velocity(0.0);
    _mdSolverInterface->getInitialVelocity(meanVelocity,_mdSolverInterface->getKB(),temperature,velocity);
    molecule.setVelocity(velocity);

    // add molecule to MD simulation and linked cell structures
    _mdSolverInterface->addMoleculeToMDSimulation(molecule);
    #if (COUPLING_MD_DEBUG==COUPLING_MD_YES)
    std::cout << "Insert particle: Success " << molecule.getPosition() << std::endl;
    #endif
  }
  #if (COUPLING_MD_DEBUG==COUPLING_MD_YES)
  else {
    std::cout << "Insert particle: Failure" << std::endl;
  }
  #endif
  return action;
}


template<class LinkedCell,unsigned int dim>
typename coupling::ParticleInsertion<LinkedCell,dim>::Action
coupling::UsherParticleInsertion<LinkedCell,dim>::deleteParticle(
  coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim>& cell,
  const coupling::BoundaryForceController<LinkedCell,dim>& boundaryForceController
)  {
  // count particles with computeMassMapping
  coupling::cellmappings::ComputeMassMapping<LinkedCell,dim> computeMassMapping(_mdSolverInterface);
  cell.iterateConstCells(computeMassMapping);
  if(computeMassMapping.getNumberOfParticles()<1){
    return coupling::ParticleInsertion<LinkedCell,dim>::NoAction;
  }

  // take a random particle
  const unsigned int randomParticle = static_cast<unsigned int>(
                                  tarch::utils::RandomNumberService::getInstance().getUniformRandomNumber()
                                  *computeMassMapping.getNumberOfParticles()
                                );
  int counter = 0;
  // delete this random particle
  coupling::cellmappings::DeleteParticleMapping<LinkedCell,dim> deleteParticleMapping(randomParticle,_mdSolverInterface);
  cell.iterateCells(deleteParticleMapping);
  while(deleteParticleMapping.getState() == 1){
    if(counter==30){
      return coupling::ParticleInsertion<LinkedCell,dim>::NoAction;
    }
    counter++;
    deleteParticleMapping.~DeleteParticleMapping();
    // take a random particle
    const unsigned int randomParticle2 = static_cast<unsigned int>(
                                    tarch::utils::RandomNumberService::getInstance().getUniformRandomNumber()
                                    *computeMassMapping.getNumberOfParticles()
                                  );

    // delete this random particle
    coupling::cellmappings::DeleteParticleMapping<LinkedCell,dim> deleteParticleMapping(randomParticle2,_mdSolverInterface);
    cell.iterateCells(deleteParticleMapping);
  }

  #ifdef USHER_DEBUG
  _energyRemoved += deleteParticleMapping.getDeletedMolecule().getPotentialEnergy();
  _ZhouEnergyRemoved += boundaryForceController.getPotentialEnergy(deleteParticleMapping.getDeletedMolecule().getPosition());
  _particlesRemoved++;
  #endif

  return coupling::ParticleInsertion<LinkedCell,dim>::Deletion;

}



template<class LinkedCell,unsigned int dim>
typename coupling::ParticleInsertion<LinkedCell,dim>::Action
coupling::UsherParticleInsertion<LinkedCell,dim>::findParticlePosition(
  coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim>& thisCell,
  const tarch::la::Vector<dim,double>& macroscopicCellPosition,
  const tarch::la::Vector<dim,double>& macroscopicCellSize,
  coupling::datastructures::Molecule<dim>& molecule,
  const coupling::BoundaryForceController<LinkedCell,dim>& boundaryForceController
)  {
  // count particles with computeMassMapping
  coupling::cellmappings::ComputeMassMapping<LinkedCell,dim> computeMassMapping(_mdSolverInterface);
  thisCell.iterateConstCells(computeMassMapping);
  // compute number density; if it's zero, we assume to have at least one particle in this cell (otherwise, we cannot choose an optimal step size for USHER)
  double numberDensity = (double)computeMassMapping.getNumberOfParticles();
  if (numberDensity ==0.0){numberDensity = 1.0;}
  for (unsigned int d = 0; d < dim; d++){numberDensity = numberDensity/macroscopicCellSize[d];}

  tarch::la::Vector<dim,double> position(0.0);
  tarch::la::Vector<dim,double> positionOld(0.0);
  tarch::la::Vector<dim,double> force(0.0);

  /** index of linked cell (within linked cell domain, NOT within macroscopic cell!) where molecule is placed in */
  tarch::la::Vector<dim,unsigned int> linkedCellIndex(0);

  // current energy
  double energy = 0.0;
  // absolute value of force
  double absForce = 0.0;
  // step size
  double stepSize = 0.0;

  // fluid parameters
  const double epsilon_times_4 = 4.0*_mdSolverInterface->getMoleculeEpsilon();
  const double sigma = _mdSolverInterface->getMoleculeSigma();

  // -------- USHER parameters ------------
  const double rSigma = _usherParams._rSigmaCoeff * _mdSolverInterface->getMoleculeSigma();
  // energy level to be reached
  const double U_0 = _usherParams._meanPotentialEnergyFactor * thisCell.getPotentialEnergy();
  // energy implying a certain overlap with another particle (including rescaling to LB scaling)
  const double U_overlap = _usherParams._uOverlapCoeff*_mdSolverInterface->getMoleculeEpsilon();
  // termination criterion (if relative energy |U-U0|/|U0| is smaller than xiMax, search can be stopped)
  const double xiMax = _usherParams._tolerance;
  // maximum step size allowed
  const double stepRef = _usherParams.getStepRef(numberDensity,_mdSolverInterface->getMoleculeSigma());
  // number of particle movements allowed to find position with energy level U_0
  const int intIterMax = _usherParams._iterMax;
  // max. number of restart tries
  const int restartMax = _usherParams._restartMax;


  // upper right and lower left boundaries for particle insertion:
  // if we are close to the very outer boundary of the domain, we only allow insertion within a distance of at least _usherParams._offsetFromOuterBoundary.
  // This is required since we may encounter instabilities due to open boundary forcing which is not included in the potential enery evaluation of the USHER scheme
  tarch::la::Vector<dim,double> upperRightBoundaries(macroscopicCellPosition+macroscopicCellSize);
  tarch::la::Vector<dim,double> lowerLeftBoundaries(macroscopicCellPosition);
  const tarch::la::Vector<dim,double> domainLower(_mdSolverInterface->getGlobalMDDomainOffset());
  const tarch::la::Vector<dim,double> domainUpper(_mdSolverInterface->getGlobalMDDomainSize()+domainLower);
  for (unsigned int d = 0; d<dim; d++){
    upperRightBoundaries[d] = fmin(upperRightBoundaries[d],domainUpper[d]-_usherParams._offsetFromOuterBoundary);
    lowerLeftBoundaries[d]  = fmax(lowerLeftBoundaries[d], domainLower[d]+_usherParams._offsetFromOuterBoundary);
    // if the offset yields, that we cannot insert any particle: return
    if (lowerLeftBoundaries[d]>upperRightBoundaries[d]){return coupling::ParticleInsertion<LinkedCell,dim>::NoAction;}
    // if (macroscopicCellSize[d] > 2.5){
    //   // that means we are at the left, lower, or front boundary
    //   if(lowerLeftBoundaries[d]==domainLower[d]+_usherParams._offsetFromOuterBoundary){
    //     upperRightBoundaries[d] = upperRightBoundaries[d]-macroscopicCellSize[d]*0.4;
    //   }
    //   // that mean we are at the right, upper, or back boundary
    //   else if(upperRightBoundaries[d]==domainUpper[d]-_usherParams._offsetFromOuterBoundary){
    //     lowerLeftBoundaries[d] = lowerLeftBoundaries[d]+macroscopicCellSize[d]*0.4;
    //   }
    // }
  }
  #ifdef USHER_DEBUG
  std::cout << std::endl << "U_0 = " << U_0 << std::endl;
  #endif
  int posFail=0;
  int energyFail=0;
  // try at max. restartMax times to insert this particle...
  for (int i = 0; i < restartMax; i++) {
    // generate random start position
    for (unsigned int d = 0; d < dim; d++ ) {
      position[d] = macroscopicCellPosition[d] +  macroscopicCellSize[d]*tarch::utils::RandomNumberService::getInstance().getUniformRandomNumber();
    }

    // determine force and energy that act on molecule
    molecule.setPosition(position);
    _mdSolverInterface->calculateForceAndEnergy( molecule);
    energy = molecule.getPotentialEnergy();
    energy += boundaryForceController.getPotentialEnergy(position);
    force = molecule.getForce();
    force += boundaryForceController.getForce(position);

    if (energy-U_0 == 0.0){
        #ifdef USHER_DEBUG
        std::cout << "energy-U_0 == 0.0" << std::endl;
        #endif
        return coupling::ParticleInsertion<LinkedCell,dim>::Insertion;
    }
    // determine signum
    int signAl = (int)((energy-U_0)/fabs(energy-U_0));
    #if (COUPLING_MD_ERROR == COUPLING_MD_YES)
    if ( (signAl != 1) && (signAl != -1) ){
      std::cout << "ERROR coupling::UsherParticleInsertion::findParticlePosition(): wrong sign in USHER" << std::endl;
      exit(EXIT_FAILURE);
    }
    #endif

    absForce = std::sqrt(tarch::la::dot(force,force));

    // do steps towards expected energy level
    double xiloc = xiMax + 1.0;
    double xiOld = xiMax + 1.0;
    int success = 0;
    int loci = 0;
    for ( ; loci < intIterMax && success<10; loci++ ) {
      // for checking, if a restart is required
      bool restartSearch=false;

      // if there is no force on the particle, we are in a low energy hole; let's try to allow this
      if (absForce==0.0){
        molecule.setPosition(position);
        molecule.setForce(force);
        molecule.setPotentialEnergy(0.0);
        #ifdef USHER_DEBUG
        std::cout << "low energy hole" << std::endl;
        #endif
        return coupling::ParticleInsertion<LinkedCell,dim>::Insertion;
      }

      // control step size
      if ( energy > U_overlap ){
        stepSize = rSigma - sigma*pow(epsilon_times_4/energy, (1.0/12.0));

      } else {
        stepSize = fabs(energy - U_0)/absForce;
        if ( stepSize > stepRef ){
          stepSize = stepRef;
        }
      }
      #if (COUPLING_MD_ERROR == COUPLING_MD_YES)
      if (stepSize <= 0.0){
        std::cout << "findParticlePosition(): ERROR coupling::UsherParticleInsertion::findParticlePosition(): Stepsize is smaller than/ equal zero!" << std::endl;
        exit(EXIT_FAILURE);
      }
      #endif

      // update particle position
      positionOld = position;
      position = position + (stepSize*signAl/absForce)*force;
      // std::cout << positionOld[0] <<" " << positionOld[1] << " " << positionOld[2] << " ";
      // std::cout << position[0] <<" " << position[1] << " " << position[2] << std::endl;

      molecule.setPosition(position);

      // restart searching if the new position of the particle is outside the macroscopic cell
      for (unsigned int d = 0; d < dim; d++ ){
        restartSearch = restartSearch
          || (position[d] >= upperRightBoundaries[d] )
          || (position[d] <= lowerLeftBoundaries[d] );
      }
      if (restartSearch){
        posFail++;
        break;
      }

      // determine force and energy that act on molecule
      _mdSolverInterface->calculateForceAndEnergy( molecule);
      energy = molecule.getPotentialEnergy();
      energy += boundaryForceController.getPotentialEnergy(position);
      force = molecule.getForce();
      force += boundaryForceController.getForce(position);
      signAl = (int)((energy-U_0)/fabs(energy-U_0));

      absForce = std::sqrt(tarch::la::dot(force,force));
      xiOld = xiloc;
      xiloc = fabs(energy-U_0)/fabs(U_0);

      if ( xiloc < xiMax ){
        success++;
      }

      // restart searching if the difference energy-U_0 increases
      if (xiloc > xiOld){
        energyFail++;
        break;
      }
    }
    if(success>0){
       molecule.setPosition(positionOld);
      _mdSolverInterface->calculateForceAndEnergy( molecule);

      #ifdef USHER_DEBUG
      _energyInserted += molecule.getPotentialEnergy();
      _ZhouEnergyInserted += boundaryForceController.getPotentialEnergy(positionOld);
      _particlesInserted++;
      energy = molecule.getPotentialEnergy();
      energy += boundaryForceController.getPotentialEnergy(positionOld);
      if(fabs(energy-U_0)/fabs(U_0) >= xiMax )
        std::cout << "USHER critical ERROR: fabs(energy-U_0)/fabs(U_0) >= xiMax" << std::endl;
      std::cout << "Finished with energy = " << energy << " after " << i
        << " restarts and " << loci << " iterations" << std::endl;
      #endif
      std::cout << "Molecule inserted at " << position[0] << " " << position[1] << " " << position[2] << std::endl;
      return coupling::ParticleInsertion<LinkedCell,dim>::Insertion;
    }
  }
  #ifdef USHER_DEBUG
  std::cout << "Failed" << std::endl;
  #endif
  std::cout << "Failed energy " << energyFail << " pos " << posFail<< std::endl;
  return coupling::ParticleInsertion<LinkedCell,dim>::NoAction;
}
