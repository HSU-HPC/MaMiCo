// Copyright (C) 2015 Technische Universitaet Muenchen
// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico

#include <fstream>
#include <string>
#include <sstream>
#include <algorithm>
#include <cstdio>
#include "coupling/interface/Molecule.h"

namespace coupling {
  namespace cellmappings {
    template<class LinkedCell,unsigned int dim>
    class usherVisPlotter;
  }
}


template<class LinkedCell,unsigned int dim>
class coupling::cellmappings::usherVisPlotter {
  public:
    usherVisPlotter(
      std::stringstream &moleculeVelocities,
      std::stringstream &moleculePositions,
      coupling::interface::MDSolverInterface<LinkedCell,dim> * const mdSolverInterface
    ): _mdSolverInterface(mdSolverInterface),_moleculeVelocities(moleculeVelocities), _moleculePositions(moleculePositions),_particleCounter(0){}

    ~usherVisPlotter(){}

    void beginCellIteration(){
      _particleCounter = 0;
    }

    void endCellIteration(){}

    void handleCell(LinkedCell& cell,const unsigned int &cellIndex){
      coupling::interface::MoleculeIterator<LinkedCell,dim> *it = _mdSolverInterface->getMoleculeIterator(cell);
      it->begin();
      while(it->continueIteration()){
        const coupling::interface::Molecule<dim> &wrapper(it->getConst());
        const tarch::la::Vector<dim,double> position = wrapper.getPosition();
        const tarch::la::Vector<dim,double> velocity = wrapper.getVelocity();
        //std::cout << "Touch molecule " << position << std::endl;
        for (unsigned int d = 0; d < dim; d++){
          _moleculePositions << position[d] << std::endl;
          _moleculeVelocities << velocity[d] << std::endl;
        }
        _moleculePositions << "-" << std::endl;
        _moleculeVelocities << "-" << std::endl;

        _particleCounter++;
        it->next();
      }
      delete it;
    }

    const unsigned int& getParticleCounter() const { return _particleCounter;}

  private:
    coupling::interface::MDSolverInterface<LinkedCell,dim> * const _mdSolverInterface;
    std::stringstream &_moleculeVelocities;
    std::stringstream &_moleculePositions;
    unsigned int _particleCounter;
};

template<class LinkedCell,unsigned int dim>
coupling::UsherParticleInsertion<LinkedCell,dim>::UsherParticleInsertion(
unsigned int insertDeleteMassEveryTimestep,
double rSigmaCoeff, double meanPotentialEnergyFactor,double uOverlapCoeff,
double stepRefCoeff,unsigned int iterMax,unsigned int restartMax,double tolerance,double offsetFromOuterBoundary,
coupling::interface::MDSolverInterface<LinkedCell,dim> * const mdSolverInterface, const tarch::la::Vector<dim,double>& macroscopicCellSize
): coupling::ParticleInsertion<LinkedCell,dim>(insertDeleteMassEveryTimestep),
#ifdef USHER_DEBUG
_energyInserted(0),
_energyRemoved(0),
_ZhouEnergyInserted(0),
_ZhouEnergyRemoved(0),
_particlesInserted(0),
_particlesRemoved(0),
#endif
_mdSolverInterface(mdSolverInterface),
_usherParams(rSigmaCoeff,meanPotentialEnergyFactor,uOverlapCoeff,stepRefCoeff,iterMax,restartMax,tolerance,offsetFromOuterBoundary)
{
  remove("usherPositions.txt");
  remove("usherVelocities.txt");
  remove("StatusDoc.txt");

  tarch::la::Vector<dim,double> size = _mdSolverInterface->getGlobalMDDomainSize();
  tarch::la::Vector<dim,double> offset = _mdSolverInterface->getGlobalMDDomainOffset();

  std::ofstream posDoc;
  posDoc.open("usherPositions.txt", std::ios::trunc);
  posDoc<<size.operator[](0)<<std::endl<<size.operator[](1)<<std::endl<<size.operator[](2)<<std::endl;
  posDoc<<offset.operator[](0)<<std::endl<<offset.operator[](1)<<std::endl<<offset.operator[](2)<<std::endl;
  posDoc<<macroscopicCellSize.operator[](0)<<std::endl<<macroscopicCellSize.operator[](1)<<std::endl<<macroscopicCellSize.operator[](2)<<std::endl;
  posDoc.close();

  std::ofstream StatusDoc;
  StatusDoc.open("StatusDoc.txt", std::ios::trunc);
  StatusDoc<<"0";
  StatusDoc.close();
}



template<class LinkedCell,unsigned int dim>
typename coupling::ParticleInsertion<LinkedCell,dim>::Action
coupling::UsherParticleInsertion<LinkedCell,dim>::insertDeleteMass(
coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim>& cell,
const tarch::la::Vector<dim,double>& macroscopicCellPosition,
const tarch::la::Vector<dim,double>& macroscopicCellSize,
const tarch::la::Vector<dim,double>& meanVelocity,
const double &temperature,
bool toBePlotted,
const coupling::BoundaryForceController<LinkedCell,dim>& boundaryForceController
) {
  typename coupling::ParticleInsertion<LinkedCell,dim>::Action action = coupling::ParticleInsertion<LinkedCell,dim>::NoAction;
  const double moleculeMass(_mdSolverInterface->getMoleculeMass());
  // if we have enough mass left in the cell, try to insert a particle and remove one particle mass
  if (cell.getMicroscopicMass() >= moleculeMass){
    action = insertParticle(cell,macroscopicCellPosition,macroscopicCellSize,meanVelocity,temperature,boundaryForceController);
    if (action == coupling::ParticleInsertion<LinkedCell,dim>::Insertion){
      cell.addMicroscopicMass(-moleculeMass);
      remove ("pathDoc.txt");
    }

  //particle insertion failed
  else{
    std::ofstream pfile("usherPositions.txt", std::ios::app);
    std::ofstream vfile("usherVelocities.txt", std::ios::app);

    pfile << "failure" << std::endl;
    vfile << "failure" << std::endl;

    std::string help;
    for (unsigned int d = 0; d < dim; d++)
    {
      help = std::to_string(macroscopicCellPosition.operator[](d));
      std::replace(help.begin(),help.end(),'.',',');
      pfile << help << std::endl;
    }

    pfile << "failpath" << std::endl;
    vfile << "failpath" << std::endl;
    std::ifstream pathDoc2in ("pathDoc.txt");
    std::stringstream data;
    data << pathDoc2in.rdbuf();
    pfile << data.str();
    pfile << "endpath" << std::endl;
    pathDoc2in.close();
    remove ("pathDoc.txt");

    std::stringstream _moleculeVelocities;
    std::stringstream _moleculePositions;

    coupling::cellmappings::usherVisPlotter<LinkedCell,dim> usherPlotter = coupling::cellmappings::usherVisPlotter(_moleculeVelocities,_moleculePositions,_mdSolverInterface);
    cell.iterateConstCells(usherPlotter);

    help = _moleculePositions.str();
    std::replace(help.begin(),help.end(),'.',',');
    pfile << help;

    help = _moleculeVelocities.str();
    std::replace(help.begin(),help.end(),'.',',');
    vfile << help;

    pfile << "break" << std::endl;
    vfile << "break" << std::endl;

    vfile.close();
    pfile.close();

    std::ofstream StatusDoc;
    StatusDoc.open("StatusDoc.txt", std::ios::trunc);
    StatusDoc<<"success";
    StatusDoc.close();
    }
  }

  // if we need to delete a particle, we try this and - in case it works - add a particle mass to the negative buffer
  else if (cell.getMicroscopicMass() <= -moleculeMass){
    action = deleteParticle(cell,boundaryForceController);
    if (action == coupling::ParticleInsertion<LinkedCell,dim>::Deletion){
      cell.addMicroscopicMass(moleculeMass);
      #if (COUPLING_MD_DEBUG==COUPLING_MD_YES)
      std::cout << "Delete particle: Success" << std::endl;
      #endif
    }
  }

  //if no particle was inserted, the algorithm did not fail inserting and no particle was deleted, only plot the cell,
  //if the microscopic mass is greater than 0.5 and the cell is at a surface of the domain
  else if(toBePlotted && std::abs(cell.getMicroscopicMass())>0.5)
  {
    std::string help;
    std::stringstream _moleculeVelocities;
    std::stringstream _moleculePositions;

    coupling::cellmappings::usherVisPlotter<LinkedCell,dim> usherPlotter = coupling::cellmappings::usherVisPlotter(_moleculeVelocities,_moleculePositions,_mdSolverInterface);
    cell.iterateConstCells(usherPlotter);

    std::ofstream pfile("usherPositions.txt", std::ios::app);
    std::ofstream vfile("usherVelocities.txt", std::ios::app);

    help = _moleculePositions.str();
    std::replace(help.begin(),help.end(),'.',',');
    pfile << help;

    help = _moleculeVelocities.str();
    std::replace(help.begin(),help.end(),'.',',');
    vfile << help;

    pfile << "break" << std::endl;
    vfile << "break" << std::endl;

    pfile.close();
    vfile.close();
  }

  return action;
}


template<class LinkedCell,unsigned int dim>
typename coupling::ParticleInsertion<LinkedCell,dim>::Action
coupling::UsherParticleInsertion<LinkedCell,dim>::insertParticle(
  coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim>& cell,
  const tarch::la::Vector<dim,double>& macroscopicCellPosition,
  const tarch::la::Vector<dim,double>& macroscopicCellSize,
  const tarch::la::Vector<dim,double>& meanVelocity,
  const double &temperature,
  const coupling::BoundaryForceController<LinkedCell,dim>& boundaryForceController
)  {
  coupling::datastructures::Molecule<dim> molecule;

  const typename coupling::ParticleInsertion<LinkedCell,dim>::Action action
  = findParticlePosition(cell,macroscopicCellPosition,macroscopicCellSize,molecule,boundaryForceController);

  // if insertion was successful, initialise velocity according to temperature in macroscopic cell
  if (action == coupling::ParticleInsertion<LinkedCell,dim>::Insertion){
    // initialise velocity of molecule
    tarch::la::Vector<dim,double> velocity(0.0);
    _mdSolverInterface->getInitialVelocity(meanVelocity,_mdSolverInterface->getKB(),temperature,velocity);
    molecule.setVelocity(velocity);
    
    //write molecules within the considered cell
    std::string help;
    std::stringstream _moleculeVelocities;
    std::stringstream _moleculePositions;

    coupling::cellmappings::usherVisPlotter<LinkedCell,dim> usherPlotter = coupling::cellmappings::usherVisPlotter(_moleculeVelocities,_moleculePositions,_mdSolverInterface);
    cell.iterateConstCells(usherPlotter);

    std::ofstream pfile("usherPositions.txt", std::ios::app);
    std::ofstream vfile("usherVelocities.txt", std::ios::app);

    help = _moleculePositions.str();
    std::replace(help.begin(),help.end(),'.',',');
    pfile << help;

    help = _moleculeVelocities.str();
    std::replace(help.begin(),help.end(),'.',',');
    vfile << help;

    //write inserted molecule's position
    for (int k = 0; k < 3; k++)
    {
      help = std::to_string(molecule.getPosition().operator[](k));
      std::replace(help.begin(),help.end(),'.',',');
      pfile << help << std::endl;
    }
    pfile << "-" << std::endl;
    pfile << "inserted" << std::endl;
    pfile.close();

    //write inserted molecule's velocity
    for (int k = 0; k < 3; k++)
    {
      help = std::to_string(molecule.getVelocity().operator[](k));
      std::replace(help.begin(),help.end(),'.',',');
      vfile << help << std::endl;
    }
    vfile << "-" << std::endl;
    vfile << "inserted" << std::endl;
    vfile.close();

    std::ofstream StatusDoc("StatusDoc.txt", std::ios::trunc);
    StatusDoc << "success";
    StatusDoc.close();


    // add molecule to MD simulation and linked cell structures
    _mdSolverInterface->addMoleculeToMDSimulation(molecule);
    #if (COUPLING_MD_DEBUG==COUPLING_MD_YES)
    std::cout << "Insert particle: Success " << molecule.getPosition() << std::endl;
    #endif
  }

  #if (COUPLING_MD_DEBUG==COUPLING_MD_YES)
  else {
    std::cout << "Insert particle: Failure" << std::endl;
  }
  #endif
  return action;
}


template<class LinkedCell,unsigned int dim>
typename coupling::ParticleInsertion<LinkedCell,dim>::Action
coupling::UsherParticleInsertion<LinkedCell,dim>::deleteParticle(
  coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim>& cell,
  const coupling::BoundaryForceController<LinkedCell,dim>& boundaryForceController
)  {
  // count particles with computeMassMapping
  coupling::cellmappings::ComputeMassMapping<LinkedCell,dim> computeMassMapping(_mdSolverInterface);
  cell.iterateConstCells(computeMassMapping);

  // take a random particle
  const unsigned int randomParticle = static_cast<unsigned int>(
                                  tarch::utils::RandomNumberService::getInstance().getUniformRandomNumber()
                                  *computeMassMapping.getNumberOfParticles()
                                );

  // delete this random particle
  coupling::cellmappings::DeleteParticleMapping<LinkedCell,dim> deleteParticleMapping(randomParticle,_mdSolverInterface);
  cell.iterateCells(deleteParticleMapping);

  #ifdef USHER_DEBUG
  _energyRemoved += deleteParticleMapping.getDeletedMolecule().getPotentialEnergy();
  _ZhouEnergyRemoved += boundaryForceController.getPotentialEnergy(deleteParticleMapping.getDeletedMolecule().getPosition());
  _particlesRemoved++;
  #endif

  std::string help;
  std::stringstream _moleculeVelocities;
  std::stringstream _moleculePositions;

  coupling::cellmappings::usherVisPlotter<LinkedCell,dim> usherPlotter = coupling::cellmappings::usherVisPlotter(_moleculeVelocities,_moleculePositions,_mdSolverInterface);
  cell.iterateConstCells(usherPlotter);

  std::ofstream pfile("usherPositions.txt", std::ios::app);
  std::ofstream vfile("usherVelocities.txt", std::ios::app);

  help = _moleculePositions.str();
  std::replace(help.begin(),help.end(),'.',',');
  pfile << help;

  help = _moleculeVelocities.str();
  std::replace(help.begin(),help.end(),'.',',');
  vfile << help;

  for (int k = 0; k < 3; k++)
  {
    help = std::to_string(deleteParticleMapping.getDeletedMolecule().getPosition().operator[](k));
    std::replace(help.begin(),help.end(),'.',',');
    pfile << help << std::endl;
  }
  pfile << "-" << std::endl;
  pfile << "removed" << std::endl;
  pfile.close();

  for (int k = 0; k < 3; k++)
  {
    help = std::to_string(deleteParticleMapping.getDeletedMolecule().getVelocity().operator[](k));
    std::replace(help.begin(),help.end(),'.',',');
    vfile << help << std::endl;
  }
  vfile << "-" << std::endl;
  vfile << "removed" << std::endl;
  vfile.close();


  std::ofstream StatusDoc;
  StatusDoc.open("StatusDoc.txt", std::ios::trunc);
  StatusDoc << "success";
  StatusDoc.close();

  return coupling::ParticleInsertion<LinkedCell,dim>::Deletion;
}



template<class LinkedCell,unsigned int dim>
typename coupling::ParticleInsertion<LinkedCell,dim>::Action
coupling::UsherParticleInsertion<LinkedCell,dim>::findParticlePosition(
  coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim>& thisCell,
  const tarch::la::Vector<dim,double>& macroscopicCellPosition,
  const tarch::la::Vector<dim,double>& macroscopicCellSize,
  coupling::datastructures::Molecule<dim>& molecule,
  const coupling::BoundaryForceController<LinkedCell,dim>& boundaryForceController
)  {
  // count particles with computeMassMapping
  coupling::cellmappings::ComputeMassMapping<LinkedCell,dim> computeMassMapping(_mdSolverInterface);
  thisCell.iterateConstCells(computeMassMapping);
  // compute number density; if it's zero, we assume to have at least one particle in this cell (otherwise, we cannot choose an optimal step size for USHER)
  double numberDensity = (double)computeMassMapping.getNumberOfParticles();
  if (numberDensity ==0.0){numberDensity = 1.0;}
  for (unsigned int d = 0; d < dim; d++){numberDensity = numberDensity/macroscopicCellSize[d];}

  tarch::la::Vector<dim,double> position(0.0);
  tarch::la::Vector<dim,double> positionOld(0.0);
  tarch::la::Vector<dim,double> force(0.0);

  /** index of linked cell (within linked cell domain, NOT within macroscopic cell!) where molecule is placed in */
  tarch::la::Vector<dim,unsigned int> linkedCellIndex(0);

  // current energy
  double energy = 0.0;
  // absolute value of force
  double absForce = 0.0;
  // step size
  double stepSize = 0.0;

  // fluid parameters
  const double epsilon_times_4 = 4.0*_mdSolverInterface->getMoleculeEpsilon();
  const double sigma = _mdSolverInterface->getMoleculeSigma();

  // -------- USHER parameters ------------
  const double rSigma = _usherParams._rSigmaCoeff * _mdSolverInterface->getMoleculeSigma();
  // energy level to be reached
  const double U_0 = _usherParams._meanPotentialEnergyFactor * thisCell.getPotentialEnergy();
  // energy implying a certain overlap with another particle (including rescaling to LB scaling)
  const double U_overlap = _usherParams._uOverlapCoeff*_mdSolverInterface->getMoleculeEpsilon();
  // termination criterion (if relative energy |U-U0|/|U0| is smaller than xiMax, search can be stopped)
  const double xiMax = _usherParams._tolerance;
  // maximum step size allowed
  const double stepRef = _usherParams.getStepRef(numberDensity,_mdSolverInterface->getMoleculeSigma());
  // number of particle movements allowed to find position with energy level U_0
  const int intIterMax = _usherParams._iterMax;
  // max. number of restart tries
  const int restartMax = _usherParams._restartMax;


  // upper right and lower left boundaries for particle insertion:
  // if we are close to the very outer boundary of the domain, we only allow insertion within a distance of at least _usherParams._offsetFromOuterBoundary.
  // This is required since we may encounter instabilities due to open boundary forcing which is not included in the potential enery evaluation of the USHER scheme
  tarch::la::Vector<dim,double> upperRightBoundaries(macroscopicCellPosition+macroscopicCellSize);
  tarch::la::Vector<dim,double> lowerLeftBoundaries(macroscopicCellPosition);
  const tarch::la::Vector<dim,double> domainLower(_mdSolverInterface->getGlobalMDDomainOffset());
  const tarch::la::Vector<dim,double> domainUpper(_mdSolverInterface->getGlobalMDDomainSize()+domainLower);
  for (unsigned int d = 0; d<dim; d++){
    upperRightBoundaries[d] = fmin(upperRightBoundaries[d],domainUpper[d]-_usherParams._offsetFromOuterBoundary);
    lowerLeftBoundaries[d]  = fmax(lowerLeftBoundaries[d], domainLower[d]+_usherParams._offsetFromOuterBoundary);
    // if the offset yields, that we cannot insert any particle: return
    if (lowerLeftBoundaries[d]>upperRightBoundaries[d]){return coupling::ParticleInsertion<LinkedCell,dim>::NoAction;}
  }

  #ifdef USHER_DEBUG
  std::cout << std::endl << "U_0 = " << U_0 << std::endl;
  #endif

  // try at max. restartMax times to insert this particle...
  for (int i = 0; i < restartMax; i++) {

    // generate random start position
    for (unsigned int d = 0; d < dim; d++ ) {
      position[d] = macroscopicCellPosition[d] +  macroscopicCellSize[d]*tarch::utils::RandomNumberService::getInstance().getUniformRandomNumber();
    }

    std::string help;
    std::ofstream pathDoc2("pathDoc.txt", std::ios::app);
    for (unsigned int d = 0; d < dim; d++)
    {
      help = std::to_string(position.operator[](d));
      std::replace(help.begin(),help.end(),'.',',');
      pathDoc2<<help<<std::endl;
    }
    pathDoc2.close();

    // determine force and energy that act on molecule
    molecule.setPosition(position);
    _mdSolverInterface->calculateForceAndEnergy( molecule);
    energy = molecule.getPotentialEnergy();
    energy += boundaryForceController.getPotentialEnergy(position);
    force = molecule.getForce();
    force += boundaryForceController.getForce(position);

    if (energy-U_0 == 0.0){
        #ifdef USHER_DEBUG
        std::cout << "energy-U_0 == 0.0" << std::endl;
        #endif
        return coupling::ParticleInsertion<LinkedCell,dim>::Insertion;
    }
    // determine signum
    int signAl = (int)((energy-U_0)/fabs(energy-U_0));
    #if (COUPLING_MD_ERROR == COUPLING_MD_YES)
    if ( (signAl != 1) && (signAl != -1) ){
      std::cout << "ERROR coupling::UsherParticleInsertion::findParticlePosition(): wrong sign in USHER" << std::endl;
      exit(EXIT_FAILURE);
    }
    #endif

    absForce = std::sqrt(tarch::la::dot(force,force));

    // do steps towards expected energy level
    double xiloc = xiMax + 1.0;
    double xiOld = xiMax + 1.0;
    int success = 0;
    int loci = 0;
    for ( ; loci < intIterMax && success<10; loci++ ) {
      // for checking, if a restart is required
      bool restartSearch=false;

      // if there is no force on the particle, we are in a low energy hole; let's try to allow this
      if (absForce==0.0){
        molecule.setPosition(position);
        molecule.setForce(force);
        molecule.setPotentialEnergy(0.0);
        #ifdef USHER_DEBUG
        std::cout << "low energy hole" << std::endl;
        #endif
        return coupling::ParticleInsertion<LinkedCell,dim>::Insertion;
      }

      // control step size
      if ( energy > U_overlap ){
        stepSize = rSigma - sigma*pow(epsilon_times_4/energy, (1.0/12.0));

      } else {
        stepSize = fabs(energy - U_0)/absForce;
        if ( stepSize > stepRef ){
          stepSize = stepRef;
        }
      }
      #if (COUPLING_MD_ERROR == COUPLING_MD_YES)
      if (stepSize <= 0.0){
        std::cout << "findParticlePosition(): ERROR coupling::UsherParticleInsertion::findParticlePosition(): Stepsize is smaller than/ equal zero!" << std::endl;
        exit(EXIT_FAILURE);
      }
      #endif

      // update particle position
      positionOld = position;
      position = position + (stepSize*signAl/absForce)*force;

      molecule.setPosition(position);

      std::string help;
      std::ofstream pathDoc2("pathDoc.txt", std::ios::app);
      for (unsigned int d = 0; d < dim; d++)
      {
        help = std::to_string(position.operator[](d));
        std::replace(help.begin(),help.end(),'.',',');
        pathDoc2<<help<<std::endl;
      }
      pathDoc2.close();
      
      // restart searching if the new position of the particle is outside the macroscopic cell
      for (unsigned int d = 0; d < dim; d++ ){
        restartSearch = restartSearch
          || (position[d] >= upperRightBoundaries[d] )
          || (position[d] <= lowerLeftBoundaries[d] );
      }
      if (restartSearch){
        break;
      }

      // determine force and energy that act on molecule
      _mdSolverInterface->calculateForceAndEnergy( molecule);
      energy = molecule.getPotentialEnergy();
      energy += boundaryForceController.getPotentialEnergy(position);
      force = molecule.getForce();
      force += boundaryForceController.getForce(position);
      signAl = (int)((energy-U_0)/fabs(energy-U_0));

      absForce = std::sqrt(tarch::la::dot(force,force));
      xiOld = xiloc;
      xiloc = fabs(energy-U_0)/fabs(U_0);

      if ( xiloc < xiMax ){ 
        success++; 
      }

      // restart searching if the difference energy-U_0 increases
      if (xiloc > xiOld){
        break;
      }
    }

    std::ofstream pathDoc("pathDoc.txt", std::ios::app);
    pathDoc << "restart" << std::endl;
    pathDoc.close();

    if(success>0){
       molecule.setPosition(positionOld);
      _mdSolverInterface->calculateForceAndEnergy( molecule);

      #ifdef USHER_DEBUG
      _energyInserted += molecule.getPotentialEnergy();
      _ZhouEnergyInserted += boundaryForceController.getPotentialEnergy(positionOld);
      _particlesInserted++;
      energy = molecule.getPotentialEnergy();
      energy += boundaryForceController.getPotentialEnergy(positionOld);
      if(fabs(energy-U_0)/fabs(U_0) >= xiMax )
        std::cout << "USHER critical ERROR: fabs(energy-U_0)/fabs(U_0) >= xiMax" << std::endl;
      std::cout << "Finished with energy = " << energy << " after " << i 
        << " restarts and " << loci << " iterations" << std::endl;
      #endif

      return coupling::ParticleInsertion<LinkedCell,dim>::Insertion;
    }
  }
  #ifdef USHER_DEBUG
  std::cout << "Failed" << std::endl;
  #endif
  return coupling::ParticleInsertion<LinkedCell,dim>::NoAction;
}