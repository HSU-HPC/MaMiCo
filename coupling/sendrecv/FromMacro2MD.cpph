// Copyright (C) 2015 Technische Universitaet Muenchen
// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico

#pragma region sequential operations

template <class Cell_T, unsigned int dim, class Container_T1, class Container_T2>
void coupling::sendrecv::FromMacro2MD<Cell_T, dim>::sendFromMacro2MD<Container_T1,Container_T2>(coupling::sendrecv::DataExchange<Cell_T, dim>& dataExchange, const Container_T1& out, const Container_T2& in) {
  // send data
  sendFromMacro2MDNonBlocking(dataExchange, in);
  // wait for MPI calls to be finished and fill coupling cells from Mamico
  wait4SendFromMacro2MD(dataExchange, out);
}

template <class Cell_T, unsigned int dim, class Container_T>
void coupling::sendrecv::FromMacro2MD<Cell_T, dim>::sendFromMacro2MDNonBlocking<Container_T>(coupling::sendrecv::DataExchange<Cell_T, dim>& dataExchange, const Container_T& cells) 
{
  // empty send and receive buffers
  coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::deleteBuffers();

  // allocate the receive buffers and trigger the MPI-recv
  allocateReceiveBuffers(dataExchange);
  // fill the send buffers
  writeToSendBuffer(dataExchange, cells);

  // allocate all requests -> needs to be called AFTER all buffers are filled
  coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::allocateRequests();

  // trigger MPI calls for send/recv
  coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::triggerReceiving(dataExchange);
  coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::triggerSending(dataExchange);
}

template <class Cell_T, unsigned int dim, class Container_T>
void coupling::sendrecv::FromMacro2MD<Cell_T, dim>::allocateReceiveBuffers<Container_T>(coupling::sendrecv::DataExchange<Cell_T, dim>& dataExchange) {
  // for (auto idx : I10())
  //   coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::allocateReceiveBuffers(dataExchange, idx);
  coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::allocateReceiveBuffers(dataExchange, couplingCellContainer);
}

template <class Cell_T, unsigned int dim, class Container_T>
void coupling::sendrecv::FromMacro2MD<Cell_T, dim>::writeToSendBuffer<Container_T>(coupling::sendrecv::DataExchange<Cell_T, dim>& dataExchange,
                                                                           const Container_T& cells) {
  // const unsigned int numberCells = (unsigned int)cells.size();
  // for (unsigned int i = 0; i < numberCells; i++)
  //   coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::writeToSendBuffer(dataExchange, *cells[i], globalCellIndices[i]);
  coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::writeToSendBuffer(dataExchange, cells);
}

template <class Cell_T, unsigned int dim, class Container_T>
void coupling::sendrecv::FromMacro2MD<Cell_T, dim>::wait4SendFromMacro2MD<Container_T>(coupling::sendrecv::DataExchange<Cell_T, dim>& dataExchange,
                                                                                const Container_T& couplingCellContainer) {
  // wait for all send- and receive operations to complete
  coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::waitAllOperations();

  // fill information from receive buffers into the coupling cells
  readFromReceiveBuffer(dataExchange, couplingCellContainer);
}

template <class Cell_T, unsigned int dim, class Container_T>
void coupling::sendrecv::FromMacro2MD<Cell_T, dim>::readFromReceiveBuffer<Container_T>(coupling::sendrecv::DataExchange<Cell_T, dim>& dataExchange,
                                                                                const Container_T& couplingCellContainer) {
//   for (auto idx : I10()) {
// #if (COUPLING_MD_ERROR == COUPLING_MD_YES)
//     coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::readFromReceiveBuffer(dataExchange, *cells.at(idx.get()), idx);
// #else
//     coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::readFromReceiveBuffer(dataExchange, *cells[idx.get()], idx);
// #endif
//   }
  coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::readFromReceiveBuffer(dataExchange, couplingCellContainer);
}

#pragma endregion // sequential operations

#pragma region collective operations
template <class Cell_T, unsigned int dim, class Container_T1, class Container_T2>
void coupling::sendrecv::FromMacro2MD<Cell_T, dim>::bcastFromMacro2MD<Container_T1, Container_T2>(
    std::vector<coupling::sendrecv::DataExchangeFromMacro2MD<dim>*>& dataExchangeFromCell_TServices,
    const Container_T1& in,
    std::vector<Container_T2> out) {
  // empty send and receive buffers
  coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::deleteBuffers();

  const unsigned int rank = IDXS.getRank();

  for (auto& de : dataExchangeFromCell_TServices) {
    if (nullptr == de)
      continue;
    // TODO compute target ranks here and pass them in
    writeToSendBufferCollective(*de, in);
    allocateReceiveBuffersCollective(*de);
  }

  SendReceiveBuffer<Cell_T, dim>::allocateBcastRequests(rank);

  // SendReceiveBuffer<Cell_T,dim >::triggerReceivingCollective(dataExchange);
  SendReceiveBuffer<Cell_T, dim>::triggerBcasts(rank);

  coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::waitAllCollectiveOperations();

  for (unsigned int i = 0; i < dataExchangeFromCell_TServices.size(); ++i) {
    if (out[i].empty())
      continue;
    if (nullptr == dataExchangeFromCell_TServices[i])
      continue;
    readFromCollectiveBuffer(*dataExchangeFromCell_TServices[i], out[i]);
  }
}

template <class Cell_T, unsigned int dim, class Container_T>
void coupling::sendrecv::FromMacro2MD<Cell_T, dim>::writeToSendBufferCollective<Container_T>(coupling::sendrecv::DataExchange<Cell_T, dim>& dataExchange,
                                                                                      const Container_T& cells,
                                                                                      const I00* const globalCellIndices) {
  const auto numberCells = (unsigned int)cells.size();
  for (unsigned int i = 0; i < numberCells; i++)
    coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::writeToBcastBuffer(dataExchange, *cells[i], globalCellIndices[i]);
}

template <class Cell_T, unsigned int dim>
void coupling::sendrecv::FromMacro2MD<Cell_T, dim>::allocateReceiveBuffersCollective(coupling::sendrecv::DataExchange<Cell_T, dim>& dataExchange) {
  for (auto idx : I10())
    coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::allocateBcastBufferForReceiving(dataExchange, idx);
}

template <class Cell_T, unsigned int dim, class Container_T>
void coupling::sendrecv::FromMacro2MD<Cell_T, dim>::readFromCollectiveBuffer<Container_T>(coupling::sendrecv::DataExchange<Cell_T, dim>& dataExchange,
                                                                                   const Container_T& cells) {
  for (auto idx : I10())
#if (COUPLING_MD_ERROR == COUPLING_MD_YES)
    coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::readFromCollectiveBuffer(dataExchange, *cells.at(idx.get()), idx);
#else
    coupling::sendrecv::SendReceiveBuffer<Cell_T, dim>::readFromCollectiveBuffer(dataExchange, *cells[idx.get()], idx);
#endif
}

#pragma endregion // collective operations
