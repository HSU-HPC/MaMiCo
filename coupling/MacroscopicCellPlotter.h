// Copyright (C) 2015 Technische Universitaet Muenchen
// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico
#ifndef _MOLECULARDYNAMICS_COUPLING_MACROSCOPICCELLPLOTTER_H_
#define _MOLECULARDYNAMICS_COUPLING_MACROSCOPICCELLPLOTTER_H_

#include <fstream>
#include <sstream>
#include "tarch/la/Vector.h"
#include "coupling/datastructures/MacroscopicCell.h"
#include "coupling/IndexConversion.h"
#include "coupling/cell-mappings/VTKMoleculePlotter.h"
#include "coupling/cell-mappings/ComputeMassMapping.h"
#include "coupling/cell-mappings/ComputeMomentumMapping.h"
#include "coupling/interface/MDSolverInterface.h"
#include "coupling/KineticEnergyController.h"

namespace coupling {
  template<class LinkedCell,unsigned int dim>
  class MacroscopicCellPlotter;
}

/** @brief plots the macroscopic cell data.
 *  @author Philipp Neumann
 *  @tparam LinkedCell the LinkedCell class is given by the implementation of linked cells in the molecular dynamics simulation
 *  @tparam dim  refers to the spacial dimension of the simulation, can be 1, 2, or 3*/
template<class LinkedCell,unsigned int dim>
class coupling::MacroscopicCellPlotter {
  public:
    /** @brief a simple constructor
     *  @param ID the id of the md simulation
     *  @param filename name for the file
     *  @param rank mpi rank of the current process
     *  @param t number of time step to plot
     *  @param indexConversion indexConversion instance of the current simulation
     *  @param cells macroscopic cells to plot
     *  @param mdSolverInterface interface of the md solver */
    MacroscopicCellPlotter(
      unsigned int ID,
      std::string filename,
      unsigned int rank,
      unsigned int t,
      const coupling::IndexConversion<dim> &indexConversion,
      coupling::datastructures::MacroscopicCells<LinkedCell,dim> &cells,
      coupling::interface::MDSolverInterface<LinkedCell,dim> * const mdSolverInterface
    ){
      plotMoleculeFile(ID,filename,rank,t,cells,mdSolverInterface);
      plotMacroscopicCellFile(ID,filename,rank,t,indexConversion,cells,mdSolverInterface);
    }

    /** @brief a simple destructor*/
    ~MacroscopicCellPlotter(){}

  private:
   /** the file will contain the velocity, position, and potentials of the molecules
    *  @brief writes molecule information to VTK file.
    *  @param ID the id of the md simulation
    *  @param filename name for the file
    *  @param rank mpi rank of the current process
    *  @param t number of time step to plot
    *  @param cells macroscopic cells to plot
    *  @param mdSolverInterface interface of the md solver */
    void plotMoleculeFile(
      unsigned int ID,
      std::string filename,
      unsigned int rank,
      unsigned int t,
      coupling::datastructures::MacroscopicCells<LinkedCell,dim> &cells,
      coupling::interface::MDSolverInterface<LinkedCell,dim> * const mdSolverInterface
    ){
      // open files
      std::ofstream moleculeFile;
      // store positions and velocities of molecules
      std::stringstream moleculeVelocities;
      std::stringstream moleculePositions;
      std::stringstream moleculePotentials;
      // zeros appended in vtk file
      std::string appendFloatZeros("");
      switch(dim){
        case 1:
          appendFloatZeros=" 0.0 0.0";
          break;
        case 2:
          appendFloatZeros=" 0.0";
          break;
        case 3:
          appendFloatZeros="";
          break;
        default:
          break;
      }
      Writer4Molecules writer(moleculeVelocities,moleculePositions,moleculePotentials,appendFloatZeros,mdSolverInterface);
      cells.applyToLocalNonGhostMacroscopicCellsWithLinkedCells(writer);
      // open file and write info
      open(ID,filename,"Molecules",rank,t,moleculeFile);
      moleculeFile << "# vtk DataFile Version 2.0" << std::endl;
      moleculeFile << "Generated by MaMiCo (Philipp Neumann)" << std::endl;
      moleculeFile << "ASCII" << std::endl;
      moleculeFile << "DATASET UNSTRUCTURED_GRID" << std::endl;
      moleculeFile << "POINTS " << writer.getMoleculeCounter() << " float" << std::endl;
      moleculeFile << moleculePositions.str() << std::endl << std::endl;
      moleculeFile << "POINT_DATA " << writer.getMoleculeCounter() << std::endl;
      moleculeFile << "VECTORS velocity float" << std::endl;
      moleculeFile << moleculeVelocities.str() << std::endl;
      moleculeFile << "SCALARS potentialEnergy float 1" << std::endl;
      moleculeFile << "LOOKUP_TABLE DEFAULT" << std::endl;
      moleculeFile << moleculePotentials.str() << std::endl;
      moleculePositions.clear(); moleculePositions.str("");
      moleculeVelocities.clear(); moleculeVelocities.str("");
      moleculePotentials.clear(); moleculePotentials.str("");
      moleculeFile.close();
    }


    /** @brief writes molecule information + macroscopic cell information to VTK file.
     *  @param ID the id of the md simulation
     *  @param filename name for the file
     *  @param rank mpi rank of the current process
     *  @param t number of time step to plot
     *  @param indexConversion indexConversion instance of the current simulation
     *  @param cells macroscopic cells to plot
     *  @param mdSolverInterface interface of the md solver */
    void plotMacroscopicCellFile(
      unsigned int ID,
      std::string filename,
      unsigned int rank,
      unsigned int t,
      const coupling::IndexConversion<dim> &indexConversion,
      coupling::datastructures::MacroscopicCells<LinkedCell,dim> &cells,
      coupling::interface::MDSolverInterface<LinkedCell,dim> * const mdSolverInterface
    ){
      // stringstreams for all cell properties of interest
      std::stringstream microscopicMasses;
      microscopicMasses << "SCALARS microscopicMassBuffer float 1" << std::endl;
      microscopicMasses << "LOOKUP_TABLE DEFAULT" << std::endl;
      std::stringstream macroscopicMasses;
      macroscopicMasses << "SCALARS macroscopicMassBuffer float 1" << std::endl;
      macroscopicMasses << "LOOKUP_TABLE DEFAULT" << std::endl;
      std::stringstream microscopicMomenta;
      microscopicMomenta << "VECTORS microscopicMomentumBuffer float" << std::endl;
      std::stringstream macroscopicMomenta;
      macroscopicMomenta << "VECTORS macroscopicMomentumBuffer float" << std::endl;
      std::stringstream meanVelocities;
      meanVelocities << "VECTORS meanVelocity float" << std::endl;
      std::stringstream masses;
      masses << "SCALARS mass float 1" << std::endl;
      masses << "LOOKUP_TABLE DEFAULT" << std::endl;
      std::stringstream energies;
      energies << "SCALARS meanPotentialEnergyBuffer float 1" << std::endl;
      energies << "LOOKUP_TABLE DEFAULT" << std::endl;
      std::stringstream temperatures;
      temperatures << "SCALARS temperature float 1" << std::endl;
      temperatures << "LOOKUP_TABLE DEFAULT" << std::endl;
      // ofstream for file
      std::ofstream ofCell;
      // zeros appended in vtk file
      std::string appendFloatZeros("");
      switch(dim){
        case 1:
          appendFloatZeros=" 0.0 0.0";
          break;
        case 2:
          appendFloatZeros=" 0.0";
          break;
        case 3:
          appendFloatZeros="";
          break;
        default:
          break;
      }
      // number of points
      const tarch::la::Vector<3,unsigned int> numberCells = coupling::initRange<dim>(indexConversion.getLocalNumberMacroscopicCells()+tarch::la::Vector<dim,unsigned int>(2));
      tarch::la::Vector<3,double> original(0.0);
      for (unsigned int d = 0; d < dim; d++){
        original[d] = indexConversion.getGlobalMDDomainOffset()[d] - 0.5*indexConversion.getMacroscopicCellSize()[d]
                    + indexConversion.getAverageLocalNumberMacroscopicCells()[d]*indexConversion.getThisProcess()[d]*indexConversion.getMacroscopicCellSize()[d];
      }
      // open file
      open(ID,filename,"MacroscopicCells",rank,t,ofCell);
      Writer4Cells writer(  microscopicMasses, macroscopicMasses,
                            microscopicMomenta, macroscopicMomenta,
                            meanVelocities, masses,
                            energies, temperatures,
                            appendFloatZeros, indexConversion, mdSolverInterface);
      cells.applyToAllLocalMacroscopicCellsWithLinkedCells(writer);
      ofCell << "# vtk DataFile Version 2.0" << std::endl;
      ofCell << "generated by MaMiCo (Philipp Neumann)" << std::endl;
      ofCell << "ASCII" << std::endl << std::endl;
      ofCell << "DATASET STRUCTURED_POINTS" << std::endl;
      ofCell << "DIMENSIONS " << numberCells[0] << " " << numberCells[1] << " " << numberCells[2] << std::endl;
      ofCell << "ORIGIN ";
      for (unsigned int d = 0; d < 3; d++){
        ofCell << original[d] << " ";
      }
      ofCell << std::endl;
      ofCell << "SPACING ";
      for (unsigned int d = 0; d < dim; d++){
        ofCell << indexConversion.getMacroscopicCellSize()[d] << " ";
      }
      for (unsigned int d = dim; d < 3; d++){
        ofCell << "1.0 ";
      }
      ofCell << std::endl;
      ofCell << "POINT_DATA " << numberCells[0]*numberCells[1]*numberCells[2] << std::endl << std::endl;
      ofCell << microscopicMasses.str() << std::endl << std::endl;
      microscopicMasses.clear(); microscopicMasses.str("");
      ofCell << macroscopicMasses.str() << std::endl << std::endl;
      macroscopicMasses.clear(); macroscopicMasses.str("");
      ofCell << masses.str() << std::endl << std::endl;
      masses.clear(); masses.str("");
      ofCell << energies.str() << std::endl << std::endl;
      energies.clear(); energies.str("");
      ofCell << temperatures.str() << std::endl << std::endl;
      temperatures.clear(); temperatures.str("");
      ofCell << microscopicMomenta.str() << std::endl << std::endl;
      microscopicMomenta.clear(); microscopicMomenta.str("");
      ofCell << macroscopicMomenta.str() << std::endl << std::endl;
      macroscopicMomenta.clear(); macroscopicMomenta.str("");
      ofCell << meanVelocities.str() << std::endl << std::endl;
      meanVelocities.clear(); meanVelocities.str("");
      // close file
      ofCell.close();
    }


    /** @brief opens a file
     *  @param ID the id of the md simulation 
     *  @param filename name for the file
     *  @param fileType type of the file (e.g. vtk)
     *  @param rank mpi rank of the current process
     *  @param t number of time step to plot
     *  @param of this is the stream, where it will be written to */
    void open(unsigned int ID, std::string filename, std::string fileType, unsigned int rank, unsigned int t, std::ofstream &of){
      std::stringstream ss;
      ss << filename << "_" << fileType << "_" << ID << "_" << rank << "_" << t << ".vtk";
      of.open(ss.str().c_str());
      if (!of.is_open()){
        std::cout << "ERROR coupling::MacroscopicCellPlotter: Could not open file " << ss.str() << "!" << std::endl;
        exit(EXIT_FAILURE);
      }
    }


    /** @brief class for writing macroscopic cell data to stringstreams.
     *  @author Philipp Neumann*/
    class Writer4Cells {
      public:
        /** @brief a simple constructor
         *  @param microscopicMasses stream for the microscopic masses
         *  @param macroscopicMasses stream for the macroscopic masses
         *  @param microscopicMomenta stream for the microscopic momenta
         *  @param macroscopicMomenta stream for the macroscopic momenta
         *  @param meanVelocities stream for the mean velocities
         *  @param masses stream for the masses
         *  @param energies stream for the energies
         *  @param temperatures stream for the temperatures
         *  @param appendFloatZeros string containing '0' to add in the case of 1d or 2d
         *  @param indexConversion instance of the indexConversion class
         *  @param mdSolverInterface interface of the md solver */
        Writer4Cells(
          std::stringstream &microscopicMasses, std::stringstream &macroscopicMasses,
          std::stringstream &microscopicMomenta,std::stringstream &macroscopicMomenta,
          std::stringstream &meanVelocities,    std::stringstream &masses,
          std::stringstream &energies,          std::stringstream &temperatures,
          const std::string &appendFloatZeros,
          const coupling::IndexConversion<dim> &indexConversion,
          coupling::interface::MDSolverInterface<LinkedCell,dim> * const mdSolverInterface
        ): _microscopicMasses(microscopicMasses),   _macroscopicMasses(macroscopicMasses),
           _microscopicMomenta(microscopicMomenta), _macroscopicMomenta(macroscopicMomenta),
           _meanVelocities(meanVelocities), _masses(masses),
           _energies(energies), _temperatures(temperatures),
           _appendFloatZeros(appendFloatZeros),
           _computeMassMapping(mdSolverInterface), _computeMomentumMapping(mdSolverInterface),
           _kineticEnergyController(mdSolverInterface),
           _indexConversion(indexConversion){}

        /** @brief a simple destructor*/
        ~Writer4Cells(){}

        /** @brief does everything which is neccessary before the application of the writer to the cells */
        void beginCellIteration(){}

        /** @brief does everything which is neccessary after the application of the writer to the cells */
        void endCellIteration(){}

        /** @brief writes the data from the cell to the stringstreams
         *  @param cell macroscopic cell
         *  @param index linearised index of the macroscopic cell*/
        void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
          // compute local quantities from molecules, if this is an inner cell
          const tarch::la::Vector<dim,unsigned int> end = _indexConversion.getLocalNumberMacroscopicCells()+tarch::la::Vector<dim,unsigned int>(1);
          const tarch::la::Vector<dim,unsigned int> localIndex = _indexConversion.getLocalVectorCellIndex(index);
          bool isInnerCell = true;
          for (unsigned int d = 0; d < dim; d++){
            isInnerCell = isInnerCell && (localIndex[d]> 0) && (localIndex[d] < end[d]);
          }
          double mass = 0.0;
          tarch::la::Vector<dim,double> meanVelocity(0.0);
          double temperature = 0.0;

          if (isInnerCell){
            cell.iterateConstCells(_computeMassMapping);
            mass = _computeMassMapping.getMass();
            cell.iterateConstCells(_computeMomentumMapping);
            meanVelocity = _computeMomentumMapping.getMeanVelocity();
            temperature = _kineticEnergyController.computeTemperature(cell);
          }

          // write data to streams
          _microscopicMasses << cell.getMicroscopicMass() << std::endl;
          _macroscopicMasses << cell.getMacroscopicMass() << std::endl;
          _masses << mass << std::endl;
          _temperatures << temperature << std::endl;
          _energies << cell.getPotentialEnergy() << std::endl;
          for (unsigned int d = 0; d < dim; d++){
            _microscopicMomenta << cell.getMicroscopicMomentum()[d] << " ";
            _macroscopicMomenta << cell.getMacroscopicMomentum()[d] << " ";
            _meanVelocities << meanVelocity[d] << " ";
          }
          _microscopicMomenta << _appendFloatZeros << std::endl;
          _macroscopicMomenta << _appendFloatZeros << std::endl;
          _meanVelocities << _appendFloatZeros << std::endl;
        }

      private:
           /** stream containing the microscopic mass of the cells (buffer to transfer mass from macro to md)*/
           std::stringstream &_microscopicMasses;
           /** stream containing the macroscopic mass of the cells (buffer to transfer mass from md to macro)*/
           std::stringstream &_macroscopicMasses;
           /** stream containing the microscopic momenta of the cells (buffer to transfer momenta from macro to md)*/
           std::stringstream &_microscopicMomenta;
           /** stream containing the macroscopic momenta of the cells (buffer to transfer momenta from md to macro )*/
           std::stringstream &_macroscopicMomenta;
           /** stream containing the mean velocity of the cells*/
           std::stringstream &_meanVelocities;
           /** stream containing the total mass in the cells*/
           std::stringstream &_masses;
           /** stream containing the total energy in the cells*/
           std::stringstream &_energies;
           /** stream containing the mean temperature in the cells*/
           std::stringstream &_temperatures;
           /** string containing '0' to add in the case of 1d or 2d */
           const std::string _appendFloatZeros;
           /** instance of the computeMassMapping*/
           coupling::cellmappings::ComputeMassMapping<LinkedCell,dim> _computeMassMapping;
           /** instance of the computeMomentumMapping*/
           coupling::cellmappings::ComputeMomentumMapping<LinkedCell,dim> _computeMomentumMapping;
           /** instance of the KineticEnergyController*/
           coupling::KineticEnergyController<LinkedCell,dim> _kineticEnergyController;
           /** instance of the indexConversion*/
           const coupling::IndexConversion<dim> &_indexConversion;
    };

    /** We make use of the traversal callback pattern of MacroscopicCells.
     *  @brief class for writing molecule data to stringstreams.
     *  @author Philipp Neumann */
    class Writer4Molecules {
      public:
        /** @brief a simple constructor
         *  @param moleculeVelocities stream for the molecule velocities
         *  @param moleculePositions stream for the molecule positions
         *  @param moleculePotentials stream for the molecule potentials
         *  @param appendFloatZeros string containing '0' to add in the case of 1d or 2d
         *  @param mdSolverInterface interface of the md solver */
        Writer4Molecules(
          std::stringstream &moleculeVelocities,
          std::stringstream &moleculePositions,
          std::stringstream &moleculePotentials,
          const std::string &appendFloatZeros,
          coupling::interface::MDSolverInterface<LinkedCell,dim> * const mdSolverInterface
        ): _moleculeVelocities(moleculeVelocities), _moleculePositions(moleculePositions),
           _moleculePotentials(moleculePotentials), _appendFloatZeros(appendFloatZeros),
           _mdSolverInterface(mdSolverInterface),
           _moleculeCounter(0){}

        /** @brief does everything which is neccessary before the application of the writer to the cells */
        void beginCellIteration(){}

        /** @brief does everything which is neccessary after the application of the writer to the cells */
        void endCellIteration(){}

        /** @brief aplication of the vtkMoleculePlotter to the macroscopic cells*/
        void apply(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
          coupling::cellmappings::VTKMoleculePlotter<LinkedCell,dim> vtkMoleculePlotter(
            _moleculeVelocities,_moleculePositions,_moleculePotentials,_appendFloatZeros,_mdSolverInterface
          );
          cell.iterateConstCells(vtkMoleculePlotter);
          _moleculeCounter += vtkMoleculePlotter.getParticleCounter();
        }

        /** @brief returns the number of molecules
         *  @returns the number of molecules plotted */
        unsigned int getMoleculeCounter() const {return _moleculeCounter;}

      private:
        /** stringstream for the velocities of the molecules*/
        std::stringstream &_moleculeVelocities;
        /** stringstream for the positions of the molecules*/
        std::stringstream &_moleculePositions;
        /** stringstream for the potentials of the molecules*/
        std::stringstream &_moleculePotentials;
        /** string containing '0' to add in the case of 1d or 2d */
        const std::string _appendFloatZeros;
        /** interface to the md solver*/
        coupling::interface::MDSolverInterface<LinkedCell,dim> * const _mdSolverInterface;
        /** counter for the molecules that have been plotted*/
        unsigned int _moleculeCounter;
    };
};
#endif // _MOLECULARDYNAMICS_COUPLING_MACROSCOPICCELLPLOTTER_H_
