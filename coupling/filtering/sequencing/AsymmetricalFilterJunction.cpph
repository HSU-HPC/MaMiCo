// This file is part of the Mamico proJunctionn conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamic::o

//Member functions of coupling::AsymmetricalFilterJunction

template<unsigned int dim>
int coupling::AsymmetricalFilterJunction<dim>::loadFiltersFromXML(tinyxml2::XMLElement* sequenceNode) { //in our case "junctionNode" would be more precise
	if(!sequenceNode) return EXIT_FAILURE;

	//null if junction is empty
    tinyxml2::XMLElement* currJunctorNode = sequenceNode->FirstChildElement();
	
	//These four are not to be confused with member variables of similar names. Watch out for the "_" in front of member variables.
	std::vector<coupling::datastructures::MacroscopicCell<dim>* > inputCellVector_primary = coupling::FilterSequence<dim>::_inputDomainCellVector;
	std::vector<coupling::datastructures::MacroscopicCell<dim>* > outputCellVector_primary = coupling::FilterSequence<dim>::_domainCellVector2;

	std::vector<coupling::datastructures::MacroscopicCell<dim>* > inputCellVector_secondary = _inputCellVector_secondary;
	//Note: To prevent counter intuitive design, secondary output has been disabled, i.e. all junctors in an AFJ take the same secondary input.
	//		There is a chance that this will be re-enabled in the future, if it is needed for a certain junctor to work.
	//std::vector<coupling::datastructures::MacroscopicCell<dim>* > outputCellVector_secondary = _cellVector2_secondary;

	#ifdef DEBUG_FILTER_PIPELINE
	std::cout << PRINT_PREFIX() << "Initializing junctor objects of asymmetrical junction." << std::endl;
	#endif	

	//Keep track of this for each indivial input partition.
	bool firstIteration = { true };

    while(currJunctorNode) {

		//All Junctors must implement one of the {X,Y}-Junctor interfaces, each of which implement FilterInterface.
		coupling::FilterInterface<dim>* newjunctor = nullptr;
		
	//###############################################################
	//This is where you have to define how to handle each junctor individually.
		
		//Write To File Junction
		//TODO: documentation about parametrization in .xml
        if(std::strcmp(currJunctorNode->Value(), "write-to-file-junction") == 0){

			//Check "overwrite" property for both underlying WriteToFile instances.
			std::array<bool,2> overwrite = { false };
			if(currJunctorNode->Attribute("wtf1-overwrite"))
				if(std::strcmp(currJunctorNode->Attribute("wtf1-overwrite"), "true") == 0)
					overwrite[0] = true;
			if(currJunctorNode->Attribute("wtf2-overwrite"))
				if(std::strcmp(currJunctorNode->Attribute("wtf2-overwrite"), "true") == 0)
					overwrite[1] = true;

			//Check "one-cell-only" property for both underlying WriteToFile instances.
			//TODO: replace std::couts with proper exceptions
			std::array<int,2> oco = { -1, -1 };
			tarch::configuration::ParseConfiguration::readIntOptional(oco[0], currJunctorNode, "wtf1-one-cell-only");
			if(oco[0] < -1 || oco[0] >= (int) inputCellVector_primary.size()) {
				std::cout << "ERROR: XML config file references undefined cell index " << oco[0] << " for primary write-to-file in write-to-file-junctor." << std::endl;
				exit(EXIT_FAILURE);
			}
			tarch::configuration::ParseConfiguration::readIntOptional(oco[1], currJunctorNode, "wtf2-one-cell-only");
			if(oco[1] < -1 || oco[1] >= (int) inputCellVector_secondary.size()) {
				std::cout << "ERROR: XML config file references undefined cell index " << oco[1] << " for secondary write-to-file in write-to-file-junctor." << std::endl;
				exit(EXIT_FAILURE);
			}
		
            newjunctor = new coupling::WriteToFileJunctor<dim>(	inputCellVector_primary,
																outputCellVector_primary,
																this->_mamicoDomainCellIndices,
																this->_sequenceDomainCellIndices,

																inputCellVector_secondary,
																_cellIndices_secondary,

																this->_filteredValues,
																{ currJunctorNode->Attribute("wtf1-location"), currJunctorNode->Attribute("wtf2-location") },
																overwrite, 
																oco);
        }

		
		else if(std::strcmp(currJunctorNode->Value(), "neuralnet") == 0){
			int epochs=0, batchSize=0;
			float learningRate=0;
			std::string modelPath="";
			
			
			std::string nnType;
			tarch::configuration::ParseConfiguration::readStringMandatory(nnType, currJunctorNode, "nnType");
			if(nnType != "standalone" && nnType != "loadModel"){
				std::cout << "ERROR: Attribute nnType for NeuralNet filter in XML config file must either be standalone or loadModel" << std::endl;
				exit(EXIT_FAILURE);
			}
			
			if(nnType == "standalone"){
				tarch::configuration::ParseConfiguration::readIntMandatory(epochs, currJunctorNode, "epochs");
				tarch::configuration::ParseConfiguration::readIntMandatory(batchSize, currJunctorNode, "batchSize");
				double tmp;
				tarch::configuration::ParseConfiguration::readDoubleMandatory(tmp, currJunctorNode, "learningRate");
				learningRate=(float)tmp;
			}
			else{
				tarch::configuration::ParseConfiguration::readStringMandatory(modelPath, currJunctorNode, "modelPath");
			}
			
            newjunctor = new coupling::NeuralNetJunctor<dim>(	
																	inputCellVector_primary, 
																	outputCellVector_primary, 
																	this->_mamicoDomainCellIndices, 
																	this->_sequenceDomainCellIndices,
																	inputCellVector_secondary, 
																	_cellIndices_secondary, 
																	this->_filteredValues,
																	
																	nnType,
																	epochs,
																	batchSize,
																	learningRate,
																	modelPath);
        }
		
    //###############################################################

		//Unknown junctor identifier
        else {
			std::cout << "ERROR: Asymmetrical Filter-Junction does not recognize junctor called " << currJunctorNode->Value() << std::endl;
            return EXIT_FAILURE;
        }

		if(firstIteration){
			inputCellVector_primary = coupling::FilterSequence<dim>::_domainCellVector1;
			inputCellVector_secondary = _cellVector1_secondary;
			firstIteration = false;
		}

		inputCellVector_primary.swap(outputCellVector_primary);

		//See comment above regarding secondary output of junctors.
		//inputCellVector_secondary.swap(outputCellVector_secondary);


        coupling::FilterSequence<dim>::_filters.push_back(newjunctor);
		currJunctorNode = currJunctorNode->NextSiblingElement();
	}

	#ifdef DEBUG_FILTER_JUNCTION_ASYM
	std::cout << PRINT_PREFIX(); this->printOutputCellVector();
	#endif
	
	return 0;
}
