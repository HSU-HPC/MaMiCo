// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico

/** Implementation of Gauss.h
 *  @author Felix Maurer
 */

//Member functions of Gauss.h:
template<unsigned int dim>
//TODO: This is very much hardcoded for kernel radius = 1
void coupling::Gauss<dim>::operator()(){	
    #ifdef DEBUG_GAUSS
    std::cout << "		GAUSS(Dim: " << _dim << "): Applying filter...";
    #endif 

	for(unsigned int index = 0; index < _cellIndices.size(); index++){

		unsigned int indexAbove = getIndexAbove(index, _dim);
		unsigned int indexBelow = getIndexBelow(index, _dim);

		//[0] = below, [1] = at index, [2] = above 
		double weights[3] = {_kernel[0], _kernel[1], _kernel[2]};

		//only one of these two cases can occur at once
		if(indexBelow == index){
			if(_extrapolationStrategy == NONE){
				//set weight of out of bounds index to zero
				weights[0] = 0;
				//normalize the other two weights
				double weightsSum = weights[1] + weights[2];
				weights[1] /= weightsSum;
				weights[2] /= weightsSum;
			}
			else if(_extrapolationStrategy == LINEAR){
				weights[0] = 0;
				//TODO: test this
				for(unsigned int si = 0; si < _scalarSetters.size(); si++)
					(_outputCells[indexAbove]
						->*(_scalarSetters[si]))
							(
								(_inputCells[indexAbove]->*(_scalarGetters[si]))()
								+
								(_inputCells[index]->*(_scalarGetters[si]))()
								+
								(_inputCells[index]->*(_scalarGetters[si]))()
								-
								(_inputCells[indexAbove]->*(_scalarGetters[si]))()
							);
				for(unsigned int vi = 0; vi < _vectorSetters.size(); vi++)
					(_outputCells[indexAbove]
						->*(_vectorSetters[vi]))
							(
								(_inputCells[indexAbove]->*(_vectorGetters[vi]))()
								+
								(_inputCells[index]->*(_vectorGetters[vi]))()
								+
								(_inputCells[index]->*(_vectorGetters[vi]))()
								-
								(_inputCells[indexAbove]->*(_vectorGetters[vi]))());
			}
			else{/*unreachable*/}

		}
		else if(indexAbove == index){
			if(_extrapolationStrategy == NONE){
				//set weight of out of bounds index to zero
				weights[2] = 0;
				//normalize the other two weights
				double weightsSum = weights[0] + weights[1];
				weights[0] /= weightsSum;
				weights[1] /= weightsSum;

			}
			else if(_extrapolationStrategy == LINEAR){
				weights[0] = 0;
				//TODO: test this
				for(unsigned int si = 0; si < _scalarSetters.size(); si++)
					(_outputCells[indexBelow]
						->*(_scalarSetters[si]))
							(
								(_inputCells[indexBelow]->*(_scalarGetters[si]))()
								+
								(_inputCells[index]->*(_scalarGetters[si]))()*2
								-
								(_inputCells[indexBelow]->*(_scalarGetters[si]))()
							);
				for(unsigned int vi = 0; vi < _scalarSetters.size(); vi++)
					(_outputCells[indexBelow]
						->*(_scalarSetters[vi]))
							(
								(_inputCells[indexBelow]->*(_scalarGetters[vi]))()
								+
								(_inputCells[index]->*(_scalarGetters[vi]))()*2
								-
								(_inputCells[indexBelow]->*(_scalarGetters[vi]))()
							);
			}
			else{/*unreachable*/}
		}
		//apply to scalars
		for(unsigned int si = 0; si < _scalarSetters.size(); si++){
			(_outputCells[index] //get cell at index i...
				->*(_scalarSetters[si])) //call scalar setter at index si
					(
						(_inputCells[indexBelow]->*(_scalarGetters[si]))() * weights[0]
						+
						(_inputCells[index]->*(_scalarGetters[si]))() * weights[1]
						+
						(_inputCells[indexAbove]->*(_scalarGetters[si]))() * weights[2]
					);
		}
		//apply to vectors	
		for(unsigned int vi = 0; vi < _vectorSetters.size(); vi++){
			(_outputCells[index]
				->*(_vectorSetters[vi]))
					(
						(_inputCells[indexBelow]->*(_vectorGetters[vi]))() * weights[0]
						+
						(_inputCells[index]->*(_vectorGetters[vi]))() * weights[1]
						+
						(_inputCells[indexAbove]->*(_vectorGetters[vi]))() * weights[2]
					);
		}
	}//index
   
    #ifdef DEBUG_GAUSS
    std::cout << "done." << std::endl;
    #endif
}

//Private functions of Gauss.h: 
template<unsigned int dim>
std::array<double, 1+2*GAUSS_KERNEL_RADIUS> coupling::Gauss<dim>::generateKernel() {
	//std::cout << "gauss: kernel radius: " << GAUSS_KERNEL_RADIUS << std::endl;	

	std::array<double, 1+2*GAUSS_KERNEL_RADIUS> kernel;
	unsigned int i = 0; //index in kernel
	double sum = 0; //used for normalization

	//fill kernel using Gaussian error function
	for(int x = -GAUSS_KERNEL_RADIUS; x <= GAUSS_KERNEL_RADIUS; x++) {
		kernel[i] = gaussianDensityFunction(x);
		sum += kernel[i];
		i++;
	}
	
	//std::cout << "gauss: kernel sum: " << sum << std::endl;

	//normalize kernel. by definition, sum cannot be 0.
	for(auto k : kernel) { 
		k *= 1/sum; 

		#ifdef DEBUG_GAUSS
    	std::cout << "		GAUSS(Dim: " << _dim << "): Add kernel entry: " << k;
    	#endif 
	}

	return kernel;
}

template<unsigned int dim>
double coupling::Gauss<dim>::gaussianDensityFunction(int x) {
	double ans = ( 1 / ( _sigma * sqrt(2*M_PI) ) ) * exp(-0.5 * (x/_sigma) * (x/_sigma));
	//std::cout << "gauss: error function at x = " << x << ": " << ans << std::endl; 
	return ans;
}


//TODO: double check these two
template<unsigned int dim>
unsigned int coupling::Gauss<dim>::getIndexAbove(unsigned int index, unsigned int d){
	unsigned int diff = 1;
	//iterate over all lower dimensions
	for(unsigned int ld = 0; ld < d; ld++) diff *= (_lastIndex[ld]+1); //*= size in ld-Dimension
	if(index + diff < _inputCells.size()) return index+diff;
	else return index; //in this case, the lower cell is nonexistant and should have weight 0

	}

template<unsigned int dim>
unsigned int coupling::Gauss<dim>::getIndexBelow(unsigned int index, unsigned int d){
	unsigned int diff = 1;
	//iterate over all lower dimensions
	for(unsigned int ld = 0; ld < d; ld++) diff *= (_lastIndex[ld]+1);
	if(index > diff) return index-diff;
	else return index; //in this case, the upper cell is nonexistant and should have weight 0
} 
