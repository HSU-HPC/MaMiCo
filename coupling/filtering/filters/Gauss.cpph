// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico

/** Implementation of Gauss.h
 *  @author Felix Maurer
 */

//Member functions of Gauss.h:
template<unsigned int dim>
//TODO: This is very much hardcoded for kernel radius = 1

//TODO: linear extrapolation makes no sense in its current implementation. check & fix
void coupling::Gauss<dim>::operator()(){	
    #ifdef DEBUG_GAUSS
    std::cout << "		GAUSS(Dim: " << _dim << "): Applying filter...";
    #endif 

	for(tarch::la::Vector<dim,unsigned int> index : this->_cellIndices) {

		auto indexAbove = getIndexAbove(index, _dim);
		auto indexBelow = getIndexBelow(index, _dim);

				
		//Used when accessing cell vectors using operator[].
		unsigned int indexLinear = _ic->getLocalCellIndex(index);
		unsigned int indexAboveLinear = _ic->getLocalCellIndex(indexAbove);
		unsigned int indexBelowLinear = _ic->getLocalCellIndex(indexBelow);

		//[0] = below, [1] = at index, [2] = above 
		double weights[3] = {_kernel[0], _kernel[1], _kernel[2]};

		//only one of these two cases can occur at once
		if(indexBelow == index){
			if(_extrapolationStrategy == NONE){
				//set weight of out of bounds index to zero
				weights[0] = 0;
				//normalize the other two weights
				double weightsSum = weights[1] + weights[2];
				weights[1] /= weightsSum;
				weights[2] /= weightsSum;
			}
			else if(_extrapolationStrategy == LINEAR){
				//set weight of out of bounds index to zero
				weights[0] = 0;
				//TODO: fix this: the arithmetic (+,...,-) makes no sense
				//double weight of upper index
				for(unsigned int si = 0; si < _scalarSetters.size(); si++)
					(_outputCells[indexAboveLinear]
						->*(_scalarSetters[si]))
							(
								(_inputCells[indexAboveLinear]->*(_scalarGetters[si]))()
								+
								(_inputCells[indexLinear]->*(_scalarGetters[si]))() * 2
								-
								(_inputCells[indexAboveLinear]->*(_scalarGetters[si]))()
							);
				for(unsigned int vi = 0; vi < _vectorSetters.size(); vi++)
					(_outputCells[indexAboveLinear]
						->*(_vectorSetters[vi]))
							(
								(_inputCells[indexAboveLinear]->*(_vectorGetters[vi]))()
								+
								(_inputCells[indexLinear]->*(_vectorGetters[vi]))()
								+
								(_inputCells[indexLinear]->*(_vectorGetters[vi]))()
								-
								(_inputCells[indexAboveLinear]->*(_vectorGetters[vi]))());
			}
			else{/*unreachable*/}

		}
		else if(indexAbove == index){
			if(_extrapolationStrategy == NONE){
				//set weight of out of bounds index to zero
				weights[2] = 0;
				//normalize the other two weights
				double weightsSum = weights[0] + weights[1];
				weights[0] /= weightsSum;
				weights[1] /= weightsSum;

			}
			else if(_extrapolationStrategy == LINEAR){
				//set weight of out of bounds index to zero
				weights[0] = 0;
				//TODO: fix this: the arithmetic (+,...,-) makes no sense
				//double weight of upper index
				for(unsigned int si = 0; si < _scalarSetters.size(); si++)
					(_outputCells[indexBelowLinear]
						->*(_scalarSetters[si]))
							(
								(_inputCells[indexBelowLinear]->*(_scalarGetters[si]))()
								+
								(_inputCells[indexLinear]->*(_scalarGetters[si]))()*2
								-
								(_inputCells[indexBelowLinear]->*(_scalarGetters[si]))()
							);
				for(unsigned int vi = 0; vi < _vectorSetters.size(); vi++)
					(_outputCells[indexBelowLinear]
						->*(_vectorSetters[vi]))
							(
								(_inputCells[indexBelowLinear]->*(_vectorGetters[vi]))()
								+
								(_inputCells[indexLinear]->*(_vectorGetters[vi]))()
								+
								(_inputCells[indexLinear]->*(_vectorGetters[vi]))()
								-
								(_inputCells[indexBelowLinear]->*(_vectorGetters[vi]))()
							);
			}
			else{/*unreachable*/}
		}
		else { //index != indexBelow != indexAbove
			//apply to scalars
			for(unsigned int si = 0; si < _scalarSetters.size(); si++){
				(_outputCells[indexLinear] //get cell at index i...
					->*(_scalarSetters[si])) //call scalar setter at index si
						(
							(_inputCells[indexBelowLinear]->*(_scalarGetters[si]))() * weights[0]
							+
							(_inputCells[indexLinear]->*(_scalarGetters[si]))() * weights[1]
							+
							(_inputCells[indexAboveLinear]->*(_scalarGetters[si]))() * weights[2]
						);
			}
			//apply to vectors	
			for(unsigned int vi = 0; vi < _vectorSetters.size(); vi++){
				(_outputCells[indexLinear]
					->*(_vectorSetters[vi]))
						(
							(_inputCells[indexBelowLinear]->*(_vectorGetters[vi]))() * weights[0]
							+
							(_inputCells[indexLinear]->*(_vectorGetters[vi]))() * weights[1]
							+
							(_inputCells[indexAboveLinear]->*(_vectorGetters[vi]))() * weights[2]
						);
			}
		}
	}//index
   
    #ifdef DEBUG_GAUSS
    std::cout << "done." << std::endl;
    #endif
}

//Private functions of Gauss.h: 
template<unsigned int dim>
std::array<double, 1+2*GAUSS_KERNEL_RADIUS> coupling::Gauss<dim>::generateKernel() {
	//std::cout << "gauss: kernel radius: " << GAUSS_KERNEL_RADIUS << std::endl;	

	std::array<double, 1+2*GAUSS_KERNEL_RADIUS> kernel;
	unsigned int i = 0; //index in kernel
	double sum = 0; //used for normalization

	//fill kernel using Gaussian error function
	for(int x = -GAUSS_KERNEL_RADIUS; x <= GAUSS_KERNEL_RADIUS; x++) {
		kernel[i] = gaussianDensityFunction(x);
		sum += kernel[i];
		i++;
	}
	
	//std::cout << "gauss: kernel sum: " << sum << std::endl;

	//normalize kernel. by definition, sum cannot be 0.
	for(auto k : kernel) { 
		k *= 1/sum; 

		#ifdef DEBUG_GAUSS
    	std::cout << "		GAUSS(Dim: " << _dim << "): Add kernel entry: " << k;
    	#endif 
	}

	return kernel;
}

template<unsigned int dim>
double coupling::Gauss<dim>::gaussianDensityFunction(int x) {
	double ans = ( 1 / ( _sigma * sqrt(2*M_PI) ) ) * exp(-0.5 * (x/_sigma) * (x/_sigma));
	//std::cout << "gauss: error function at x = " << x << ": " << ans << std::endl; 
	return ans;
}


template<unsigned int dim>
tarch::la::Vector<dim, unsigned int> coupling::Gauss<dim>::getIndexAbove(const tarch::la::Vector<dim, unsigned int> index, unsigned int d){
	//check for border indices
	if(index[d] == _lastIndex[d]) return index;

	//copy input index
	auto ans = tarch::la::Vector<dim, unsigned int>(index);

	//get upper index in dimension d
	ans[d] += 1;
	return ans;
}

template<unsigned int dim>
tarch::la::Vector<dim, unsigned int> coupling::Gauss<dim>::getIndexBelow(const tarch::la::Vector<dim, unsigned int> index, unsigned int d){
	//check for border indices
	if(index[d] == 0) return index;

	//copy input index
	auto ans = tarch::la::Vector<dim, unsigned int>(index);

	//get lower index in dimension d
	ans[d] -= 1;
	return ans;
} 
