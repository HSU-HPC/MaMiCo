// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico

//Implementaions of a pipeline-like approach used for chanining and branching of filters for MacrosCopicCells.
//@Author Felix Maurer

//CLASS FILTER SEQUENCE
//Member functions of coupling::FilterSequence

template<unsigned int dim, class CellService>
int coupling::FilterSequence<dim, CellService>::loadFiltersFromXML(tinyxml2::XMLElement* sequenceNode){
	if(!sequenceNode) return EXIT_FAILURE;
    tinyxml2::XMLElement* currFilterNode = sequenceNode->FirstChildElement();
    while(currFilterNode){
		#ifdef DEBUG_FILTER_PIPELINE
		std::cout << "FP: Initializing filter objects of sequence " << _name << ": ";
		#endif

        //Filter identifiers are hardcoded (for now at least):
        if(std::strcmp(currFilterNode->Value(), "write-to-file") == 0)
        {
			#ifdef DEBUG_FILTER_PIPELINE
			std::cout << "Write-To-File" << std::endl;
			#endif

            //coupling::WriteToFile<dim> currFilter(currFilterNode->Attribute("location"));
			//TODO: move this
        }
        else if(std::strcmp(currFilterNode->Value(), "POD") == 0) {
        //TODO
			std::cout << "ERROR: Filter-Pipeline does not yet support POD." << std::endl;
            //exit(EXIT_FAILURE);
        }
        else if(std::strcmp(currFilterNode->Value(), "NLM") == 0) {
            //TODO
            std::cout << "ERROR: Filter-Pipeline does not yet support NLM." << std::endl;
            //exit(EXIT_FAILURE);
        }
        else {
			std::cout << "ERROR: Filter-Pipeline does not recognize filter called " << currFilterNode->Value() << std::endl;
            //exit(EXIT_FAILURE);
        }

            currFilterNode = currFilterNode->NextSiblingElement();
        }
	return 0;
}

template<unsigned int dim, class CellService>
void coupling::FilterSequence<dim, CellService>::fillSequenceData(
    std::vector<coupling::datastructures::MacroscopicCell<dim>* > mdCellVector,
    std::vector<int> mdCellIndices
){
    //Reset data vectors
    _macroscopicCells.clear();
    _cellIndices.clear();

    //If the input of a sequence is not defined, it's assumed to be the default input i.e. MD
    if(_input == nullptr){
        for(auto mdCell : mdCellVector){
            _macroscopicCells.push_back(mdCell);
        }
        for(auto mdCellIndex : mdCellIndices){
            _cellIndices.push_back(mdCellIndex);
        }
        #ifdef DEBUG_FILTER_PIPELINE
        std::cout << "FP: Supplied sequence named " << _name << " with cell data from MD." << std::endl;
        #endif
    }
    else{
        for(auto mdCell : _input->getMacroscopicCells()){
            _macroscopicCells.push_back(mdCell);
        }
        for(auto mdCellIndex : _input->getCellIndices()){
            _cellIndices.push_back(mdCellIndex);
        }
        #ifdef DEBUG_FILTER_PIPELINE
        std::cout << "FP: Supplied sequence named " << _name << " with cell data from " << _input->getName() << std::endl;
        #endif
    }
}

//CLASS FILTER PIPELINE
//constructors of coupling::FilterPipeline
template<unsigned int dim, class CellService>
coupling::FilterPipeline<dim, CellService>::FilterPipeline(const std::string cfgpath){
        FilterPipeline(POST_MULTI_INSTANCE_FILTERING_NO, cfgpath);
}


template<unsigned int dim, class CellService>
coupling::FilterPipeline<dim, CellService>::FilterPipeline(
	bool postMultiInstance, 
	const std::string cfgpath)
	: _postMultiInstance(postMultiInstance)
{
    //check if provided file is written in proper XML
    if(_config.LoadFile(cfgpath.c_str()) != tinyxml2::XML_NO_ERROR){
        std::cout << "ERROR: Could not read config for Filter-Pipeline: XML syntax error." << std::endl;
        exit(EXIT_FAILURE);
    }
            
    //check for structural errors in config file
    if (!configIsValid(_config)) exit(EXIT_FAILURE);

    //load sequences
    if (_postMultiInstance){
        if(loadSequencesFromXML(_config.FirstChildElement("filter-pipeline")->FirstChildElement("post-multi-instance"))) exit(EXIT_FAILURE);
    }
    else if(loadSequencesFromXML(_config.FirstChildElement("filter-pipeline")->FirstChildElement("per-instance"))) exit(EXIT_FAILURE);
}

//member functions of coupling::FilterPipeline
template<unsigned int dim, class CellService>
void coupling::FilterPipeline<dim, CellService>::apply(const unsigned int * const globalCellIndices, CellService* cellService){
    
    //initialize md data
    std::vector<coupling::datastructures::MacroscopicCell<dim>* > md_cells = cellService->getMacroscopicCells().getMacroscopicCells();
    std::vector<int> md_indices = {0,1};//TODO: replace with usage of globalCellIndices

	//select between PI and MI
	//TODO: dont copy all the sequences: pointers?
	std::vector<coupling::FilterSequence<dim, CellService>* > sequences;
	if(_postMultiInstance){
		sequences = _miSequences;
		#ifdef DEBUG_FILTER_PIPELINE
		std::cout << "FP: Starting to apply multi-instance filters." << std::endl;
		#endif
	}
	else{
		sequences = _piSequences;
		#ifdef DEBUG_FILTER_PIPELINE
		std::cout << "FP: Starting to apply per instance filters." << std::endl;
		#endif
	}

    for(coupling::FilterSequence<dim, CellService>* currSequence : sequences){
		#ifdef DEBUG_FILTER_PIPELINE
		std::cout << "FP: Loading cell data for sequence " << currSequence->getName() << std::endl;
		#endif

		//md data does not neccesarily get used
        currSequence->fillSequenceData(md_cells, md_indices);

		for(coupling::FilterInterface<dim>* currFilter : currSequence->getFilters())
			currFilter->apply(currSequence->getMacroscopicCells(), currSequence->getMacroscopicCells(), currSequence->getCellIndices(), cellService->getIndexConversion());

        #ifdef DEBUG_FILTER_PIPELINE
		std::cout << "FP: Done applying sequence " << currSequence->getName() << std::endl;
		#endif
	
		//If !isOutput for all sequences, "md" must be our output. This is equivalent to a read-only filter pipeline.
		if(currSequence->isOutput()) /*TODO: Set MacroscopicCells from this sequence as cellService's cells.*/;
    }
}




//Private functions of coupling::FilterPipeline:
template<unsigned int dim, class CellService>
bool coupling::FilterPipeline<dim, CellService>::configIsValid(tinyxml2::XMLDocument& cfgfile){
    //Check main node 
    tinyxml2::XMLElement* node = cfgfile.FirstChildElement("filter-pipeline");
    if (!node){
        std::cout << "ERROR: Could not read config for Filter-Pipeline: missing element <filter-pipeline>" << std::endl;
        return false;
    }

    if (node->NextSiblingElement()){
        std::cout << "ERROR: Could not read config for Filter-Pipeline: should not contain more than one root element" << std::endl;
        return false;
    }

    //verfiy per-instance subtag
    tinyxml2::XMLElement* perInstanceTag = node->FirstChildElement("per-instance");
    if(!perInstanceTag){
        std::cout << "ERROR: Could not read config for Filter-Pipeline: missing element <per-instance>" << std::endl;
        return false;
    }
	if(!perInstanceTag->Attribute("output")){
		std::cout << "ERROR: Could not read config for Filter-Pipeline: no output specified for <per-instance>" << std::endl;
	}

    //verify multi-instance subtag
	tinyxml2::XMLElement* multiInstanceTag = node->FirstChildElement("post-multi-instance");
    if(!multiInstanceTag){
		std::cout << "ERROR: Could not read config for Filter-Pipeline: missing element <post-multi-instance>" << std::endl;
        return false;
    }
	if(!multiInstanceTag->Attribute("output")){
		std::cout << "ERROR: Could not read config for Filter-Pipeline: no output specified for <post-multi-instance>" << std::endl;
		return false;
	}

        //No checks are done to determine if any more subtags of main node exist as they do not interfer with implementation of this class.
        //Syntax checking for sequence-subnodes can be found in their respective initializer methods.

    #ifdef DEBUG_FILTER_PIPELINE
    std::cout << "FP: Config is valid!" << std:: endl;
    #endif

    return true;
}

//Initializes name and input pointer (if input is MD, that pointer is null). Does NOT initialize any data.
template<unsigned int dim, class CellService>
int coupling::FilterPipeline<dim, CellService>::loadSequencesFromXML(tinyxml2::XMLElement* node){
    
    tinyxml2::XMLElement* currSequenceNode = node->FirstChildElement();
    std::vector<coupling::FilterSequence<dim, CellService> *> knownSequences;
    
    //Check if all outputs are specified before being used by sequences
    while(currSequenceNode){
        FilterSequence<dim, CellService>* inputFilterSequence = nullptr;
        const char* inputName = currSequenceNode->Attribute("input");

        if(!inputName) inputName = "md";
        bool sequenceRecognized = false;
        
        //search temp vector of known sequences
        for(auto seq : knownSequences){
            if(std::strcmp(seq->getName(), inputName) == 0) {
                inputFilterSequence = seq;
                sequenceRecognized = true;
                break;
            }
        }
        //"md" is the default input and is not associated to any sequence
        if(std::strcmp(inputName,"md") == 0) sequenceRecognized = true;
        
        if(!sequenceRecognized){
            std::cout << "ERROR: Filter-Pipeline: Invalid input " << inputName << " specified for sequence named " << currSequenceNode->Value() << std::endl;
            return EXIT_FAILURE;
        }

        //Add sequence to temp vector
        if(inputFilterSequence) knownSequences.push_back(new coupling::FilterSequence<dim, CellService>(currSequenceNode->Value(), inputFilterSequence));
        else knownSequences.push_back(new coupling::FilterSequence<dim, CellService>(currSequenceNode->Value()));

		//Check if it's the output sequence. If none of the sequences' names match, "md" is assumed as output.
		if(std::strcmp(knownSequences.back()->getName(),  node->Attribute("output")) == 0){
			knownSequences.back()->setAsOutput();
			#ifdef DEBUG_FILTER_PIPELINE
			std::cout << "This sequence will be used as the output sequence." << std::endl;
			#endif
		}
		
		//Load filters of the newly created sequence
		if(knownSequences.back()->loadFiltersFromXML(currSequenceNode)) return EXIT_FAILURE;

        //Proceed to iterate over next element
        currSequenceNode = currSequenceNode->NextSiblingElement();
    }

    if(_postMultiInstance){
        _miSequences = knownSequences;
		#ifdef DEBUG_FILTER_PIPELINE
        std::cout << "FP: Post multi-instance sequences loaded!" << std:: endl;
		#endif
    }
    else{
        _piSequences = knownSequences;
		#ifdef DEBUG_FILTER_PIPELINE
        std::cout << "FP: Per-instance sequences loaded!" << std:: endl;
		#endif
    }

    return 0;
}


/** 
TODO:
CellService doch nicht ins template?
*/
