// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico

//constructors of coupling::FilterPipeline
template<unsigned int dim>
coupling::FilterPipeline<dim>::FilterPipeline(
	std::vector<coupling::datastructures::MacroscopicCell<dim>* > inputCells,
	const coupling::IndexConversion<dim>* indexConversion,
	coupling::interface::MacroscopicSolverInterface<dim>* msi,
	const tarch::utils::MultiMDService<dim>& multiMDService,
	const std::string cfgpath):
    FilterPipeline(inputCells, indexConversion, msi, multiMDService, POST_MULTI_INSTANCE_FILTERING_NO, cfgpath)
{}

template<unsigned int dim>
coupling::FilterPipeline<dim>::FilterPipeline(
	std::vector<coupling::datastructures::MacroscopicCell<dim>* > inputCells,
	const coupling::IndexConversion<dim>* indexConversion,
	coupling::interface::MacroscopicSolverInterface<dim>* msi,
	const tarch::utils::MultiMDService<dim>& multiMDService,
	bool postMultiInstance, 
	const std::string cfgpath):

	_multiMDService(multiMDService),
	_postMultiInstance(postMultiInstance)
{
	_ic = new coupling::IndexConversionMD2Macro<dim>(indexConversion, msi);
	
    //check if provided file is written in proper XML
    if(_config.LoadFile(cfgpath.c_str()) != tinyxml2::XML_NO_ERROR){
        std::cout << "ERROR: Could not read config for Filter-Pipeline: XML syntax error." << std::endl;
        exit(EXIT_FAILURE);
    }
            
    //check for structural errors in config file
    if (!configIsValid(_config)) exit(EXIT_FAILURE);
	
	//load domain vectors
	_ic->initMD2MacroDomain(inputCells, _md2MacroCells, _md2MacroCellIndices);

    //load sequences
    if (_postMultiInstance){
        if(loadSequencesFromXML(_config.FirstChildElement("filter-pipeline")->FirstChildElement("post-multi-instance"))) exit(EXIT_FAILURE);
    }
    else if(loadSequencesFromXML(_config.FirstChildElement("filter-pipeline")->FirstChildElement("per-instance"))) exit(EXIT_FAILURE);
}


//member functions of coupling::FilterPipeline
template<unsigned int dim>
void coupling::FilterPipeline<dim>::operator()(){
    //select between PI and MI
	std::vector<coupling::FilterSequence<dim>* > sequences;
	if(_postMultiInstance){
		sequences = _miSequences;
		#ifdef DEBUG_FILTER_PIPELINE
		std::cout << "FP: Starting to apply multi-instance filters." << std::endl;
		#endif
	}
	else{
		sequences = _piSequences;
		#ifdef DEBUG_FILTER_PIPELINE
		std::cout << "FP: Starting to apply per instance filters." << std::endl;
		#endif
	}

	//std::cout << "FP: BEFORE: " << _md2MacroCells[10]->getCurrentVelocity() << std::endl << std::endl;

    for(coupling::FilterSequence<dim>* currSequence : sequences){
		//finalize FS's filter vector
		if(currSequence->isModifiable() == true){
			//output of only rank 1
			currSequence->printFilters();
			currSequence->makeUnmodifiable();
		}
		
		//update cell vector contents	
		currSequence->updateCellVectors();
		//apply all filters of sequence
		for(coupling::FilterInterface<dim>* currFilter : currSequence->getFilters()) (*currFilter)();

        #ifdef DEBUG_FILTER_PIPELINE
		std::cout << "FP: Done applying sequence " << currSequence->getName() << std::endl;
		#endif

		//If !isOutput for all sequences, "md" must be our output. This is equivalent to a read-only filter pipeline.
		if(currSequence->isOutput()){
			std::vector<coupling::datastructures::MacroscopicCell<dim>* > sequenceOutputCells = currSequence->getOutputCellVector(); 
			for(unsigned int index = 0; index < _md2MacroCells.size(); index++) *(_md2MacroCells[index]) = *(sequenceOutputCells[index]);
		}
    }

	//std::cout << std::endl << "FP: AFTER: " << _md2MacroCells[10]->getCurrentVelocity() << std::endl;
}




//Private functions of coupling::FilterPipeline:
template<unsigned int dim>
bool coupling::FilterPipeline<dim>::configIsValid(tinyxml2::XMLDocument& cfgfile){
    //Check main node 
    tinyxml2::XMLElement* node = cfgfile.FirstChildElement("filter-pipeline");
    if (!node){
        std::cout << "ERROR: Could not read config for Filter-Pipeline: missing element <filter-pipeline>" << std::endl;
        return false;
    }

    //verfiy per-instance subtag
    tinyxml2::XMLElement* perInstanceTag = node->FirstChildElement("per-instance");
    if(!perInstanceTag){
        std::cout << "ERROR: Could not read config for Filter-Pipeline: missing element <per-instance>" << std::endl;
        return false;
    }
	if(!perInstanceTag->Attribute("output")){
		std::cout << "ERROR: Could not read config for Filter-Pipeline: no output specified for <per-instance>" << std::endl;
	}

    //verify multi-instance subtag
	tinyxml2::XMLElement* multiInstanceTag = node->FirstChildElement("post-multi-instance");
    if(!multiInstanceTag){
		std::cout << "ERROR: Could not read config for Filter-Pipeline: missing element <post-multi-instance>" << std::endl;
        return false;
    }
	if(!multiInstanceTag->Attribute("output")){
		std::cout << "ERROR: Could not read config for Filter-Pipeline: no output specified for <post-multi-instance>" << std::endl;
		return false;
	}

        //No checks are done to determine if any more subtags of main node exist as they do not interfer with implementation of this class.
        //Syntax checking for sequence-subnodes can be found in their respective initializer methods.

    #ifdef DEBUG_FILTER_PIPELINE
    std::cout << "FP: Config is valid!" << std:: endl;
    #endif

    return true;
}

//TODO: refactor/rework?
template<unsigned int dim>
int coupling::FilterPipeline<dim>::loadSequencesFromXML(tinyxml2::XMLElement* node){

	//sanity check
	if(_md2MacroCells.empty()) {
		std::cout << "Warning: Empty md2Macro-Domain in Filter Pipeline. Disabling filtering." << std::endl;
		return 0;
	}
	
    tinyxml2::XMLElement* currSequenceNode = node->FirstChildElement();
    std::vector<coupling::FilterSequence<dim> *> knownSequences;
    
    //Check if all outputs are specified before being used by sequences
    while(currSequenceNode){
		//FINDING INPUT
        FilterSequence<dim>* inputFilterSequence = nullptr;
        const char* inputName = currSequenceNode->Attribute("input");

		if(std::strcmp(currSequenceNode->Value(), "md") == 0){
			std::cout << "ERROR: Filter-Pipeline: Sequence name may not be 'md'." << std::endl;
			exit(EXIT_FAILURE);
		}

        if(!inputName) inputName = "md";
        bool sequenceRecognized = false; 
        //search temp vector of known sequences
		//TODO: check if this sequence's name is already occupied
        for(auto seq : knownSequences){
            if(std::strcmp(seq->getName(), inputName) == 0) {
                inputFilterSequence = seq;
                sequenceRecognized = true;
                break;
            }
        }
        //"md" is the default input and is not associated to any sequence
        if(std::strcmp(inputName,"md") == 0) sequenceRecognized = true;
        
        if(!sequenceRecognized){
            std::cout << "ERROR: Filter-Pipeline: Invalid input " << inputName << " specified for sequence named " << currSequenceNode->Value() << std::endl;
            return EXIT_FAILURE;
        }

   		//DOMAIN LIMITING
    	tarch::la::Vector<dim, double> domainStart;
   	 	tarch::la::Vector<dim, double> domainEnd;
		//default domain boundaries
    	tarch::la::Vector<dim, unsigned int> domainStartCell = _md2MacroCellIndices.front();
    	tarch::la::Vector<dim, unsigned int> domainEndCell = _md2MacroCellIndices.back();

		//if custom start/end is specified use that instead
        if(currSequenceNode->Attribute("domain-start")){ 
			tarch::configuration::ParseConfiguration::readVector<dim, double>(domainStart, currSequenceNode, "domain-start");
	        for(unsigned int d = 0; d < dim; d++){
    	        domainStartCell[d] = (unsigned int) std::floor(domainStart[d] / (*_ic)()->getMacroscopicCellSize()[d]);
  			    domainEndCell[d] = (unsigned int) std::ceil(domainEnd[d] / (*_ic)()->getMacroscopicCellSize()[d]);
        	}
		}
        if(currSequenceNode->Attribute("domain-end")){
			tarch::configuration::ParseConfiguration::readVector<dim, double>(domainEnd, currSequenceNode, "domain-end");
	        for(unsigned int d = 0; d < dim; d++){
    	        domainStartCell[d] = (unsigned int) std::floor(domainStart[d] / (*_ic)()->getMacroscopicCellSize()[d]);
        	    domainEndCell[d] = (unsigned int) std::ceil(domainEnd[d] / (*_ic)()->getMacroscopicCellSize()[d]);
        	}
		}

		//"filtered-values" is not mandatory, default is false
		std::array<bool, 7> filteredValues = {false};
		const char* fvStr = currSequenceNode->Attribute("filtered-values");
		if(fvStr){
			if(strstr(fvStr, "all")) for(unsigned int i = 0; i < 7; i++) filteredValues[i] = true;
			else{
				if(strstr(fvStr, "micro-mass")) filteredValues[0] = true;
				if(strstr(fvStr, "micro-momentum")) filteredValues[1] = true;
				if(strstr(fvStr, "macro-mass")) filteredValues[2] = true;
				if(strstr(fvStr, "macro-momentum")) filteredValues[3] = true;
				if(strstr(fvStr, "potential-energy")) filteredValues[4] = true;
				if(strstr(fvStr, "velocity")) filteredValues[5] = true;
				if(strstr(fvStr, "temperature")) filteredValues[6] = true;
			}
		}
		
		//CREATE SEQUENCE
		if(inputFilterSequence){
			knownSequences.push_back(new coupling::FilterSequence<dim>(_ic, _multiMDService, currSequenceNode->Value(), inputFilterSequence->getOutputCellVector(), _md2MacroCellIndices, domainStartCell, domainEndCell, filteredValues));
			#ifdef DEBUG_FILTER_PIPELINE
			std::cout << "FP: " << knownSequences.back()->getName() << " will use " << inputFilterSequence->getName() << " as input." << std::endl;
			#endif
		}
		else {
			knownSequences.push_back(new coupling::FilterSequence<dim>(_ic, _multiMDService, currSequenceNode->Value(), _md2MacroCells, _md2MacroCellIndices, domainStartCell, domainEndCell, filteredValues));
			#ifdef DEBUG_FILTER_PIPELINE
			std::cout << "FP: " << knownSequences.back()->getName() << " will use MD data as input." << std::endl;
			#endif
		}
        //Add sequence to temp vector
		//Check if it's the output sequence. If none of the sequences' names match, "md" is assumed as output.
		if(std::strcmp(knownSequences.back()->getName(),  node->Attribute("output")) == 0){
			knownSequences.back()->setAsOutput();
		}

		//Load filters of the newly created sequence
		if(knownSequences.back()->loadFiltersFromXML(currSequenceNode)) return EXIT_FAILURE;

        //Proceed to iterate over next element
        currSequenceNode = currSequenceNode->NextSiblingElement();
    }

    if(_postMultiInstance){
        _miSequences = knownSequences;
		#ifdef DEBUG_FILTER_PIPELINE
        std::cout << "FP: Post multi-instance sequences loaded!" << std:: endl;
		#endif
    }
    else{
        _piSequences = knownSequences;
		#ifdef DEBUG_FILTER_PIPELINE
        std::cout << "FP: Per-instance sequences loaded!" << std:: endl;
		#endif
  }

    return 0;
}
