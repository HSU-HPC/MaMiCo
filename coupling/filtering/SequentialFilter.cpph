// This file is part of_outputCells_Localconditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico


//Implementation of SequentialFilter.h

//CONSTRUCTOR
template <unsigned int dim>
coupling::filtering::SequentialFilter<dim>::SequentialFilter(
	coupling::filtering::FilterInterface<dim>* filter,
	const MPI_Comm comm
):
	coupling::filtering::FilterInterface<dim>("SEQUENTIALIZED_FILTER"),
	_filter(filter),
	_comm(comm),
	_processingRank(0), //TODO: Make this customizable.
	_cellbuf()
{
	MPI_Comm_rank(_comm, &_myRank);
	MPI_Comm_size(_comm, &_commSize);	

	#ifdef DEBUG_SEQ_FILTER
	std::cout << "		SEQFILTER (" << _myRank << "): Now initializing sequentialized Filter of type: " << _filter->getType() <<std::endl;
	#endif

	if(_commSize > 1) {
		//allocate global cell data structures for processing rank only
		if( _processingRank == _myRank) {
			//filter's input cell pointers will be overwritten, but we need this information in contribute()
			
			_inputCells_Local = _filter->getInputCells(); 
			_outputCells_Local = _filter->getOutputCells(); 			

			//allocate global cell datastructures
			unsigned int numcells = coupling::indexing::CellIndex<dim,
				coupling::indexing::IndexTrait::md2macro, coupling::indexing::IndexTrait::noGhost>
				::linearNumberCellsInDomain;
			for(unsigned int c = 0; c < numcells; c++) {
				_inputCells_Global.push_back(new coupling::datastructures::MacroscopicCell<dim>());
				_outputCells_Global.push_back(new coupling::datastructures::MacroscopicCell<dim>());
			}
		}//end: if rank processing rank

		//Resize if buffers are too small to contain cell data
		if(_cellbuf.capacity() < 4+3*dim) {
			_cellbuf.resize(4+3*dim); 
			#ifdef DEBUG_SEQ_FILTER
			std::cout << "		SEQFILTER (" << _myRank << "): Cell buffer resized to: " << _cellbuf.size() << std::endl;
			#endif
		}
	}//end: if _commSize > 1

	//case: _commSize = 1, i.e. single process
	else {
		_commSize = 1;
		#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): Warning: SequentialFilter operating on one rank only." << std::endl;
		#endif
	}
}

//MEMBER FUNCTIONS
template<unsigned int dim>
void coupling::filtering::SequentialFilter<dim>::operator()(){	
	if(_commSize > 1) {
		if(_processingRank == _myRank) {
			contribute();
			process(FILTER_SEQUENTIAL);
		}
		else contribute();
	}
	else process(FILTER_PARALLEL);
}

		
//PRIVATE FUNCTIONS
template<unsigned int dim>
void coupling::filtering::SequentialFilter<dim>::contribute() {	
	#ifdef DEBUG_SEQ_FILTER
	std::cout << "		SEQFILTER (" << _myRank << "): Sending cells and indices." << std::endl;
	#endif

	if(_processingRank == _myRank) {
		//Count cells that we update. This should be equal to _inputCells_Global.size().
		unsigned int cellsUpdated = 0;
		
		//Iterate over all (contributing) ranks...
		for(int rank = 0; rank < _commSize; rank++) {

			//Case: The contributing rank is the processing rank. In this case, we only need to copy cell data.
			if(rank == _myRank) {
				#ifdef DEBUG_SEQ_FILTER
					std::cout << "		SEQFILTER (" << _myRank << "): Copying " << _inputCells_Local.size() << " cells from local on processing rank " << rank << std::endl;
				#endif
				//Copy all cell data to global data structures. TODO: use std list and concat
				for(unsigned int c = 0; c < _inputCells_Local.size(); c++) {
					*(_inputCells_Global[cellsUpdated]) = *(_inputCells_Local[c]);
					cellsUpdated++;
				}

				#ifdef DEBUG_SEQ_FILTER
					std::cout << "		SEQFILTER (" << _myRank << "): Copied a total of " << cellsUpdated << " cells." << std::endl;
				#endif
			}

			//Case: the contributing rank is not the processing rank. We need to communicate cell data using MPI.
			else {
				//Receive number of cells+indices that will be sent from that rank
				unsigned int numberOfCellsFromRank;
				MPI_Recv(&numberOfCellsFromRank, 1, MPI_UNSIGNED, rank, 0, _comm, MPI_STATUS_IGNORE);
				#ifdef DEBUG_SEQ_FILTER
				std::cout << "		SEQFILTER (" << _myRank << "): Expecting a total of " << numberOfCellsFromRank << " cells and indices from rank " << rank << std::endl;
				#endif

				//Receive that many cells
				for(unsigned int c = 0; c < numberOfCellsFromRank; c++) { //TODO: receive all cells at once
					//receive cell
					MPI_Recv(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, rank, 0, _comm, MPI_STATUS_IGNORE);

					//Insert data received into global cell data structures TODO: use std list and concat
					bufferToMacroscopicCell(_cellbuf, _inputCells_Global[cellsUpdated]);
					
					cellsUpdated++;

					#ifdef DEBUG_SEQ_FILTER_VERBOSE
					std::cout << "			SEQFILTER (" << _myRank << "): Received cell from rank " << rank << std::endl;
					#endif

				}
			}

			#ifdef DEBUG_SEQ_FILTER
			std::cout << "		SEQFILTER (" << _myRank << "): Received cells and indices from rank " << rank << std::endl;
			#endif
		}	

		//This rank now processes...
	}
	else /* contributing rank */{
		
		//Communicate to processing rank how many cells+indices will be send
		unsigned int numberOfCellsFromThisRank = _filter->getInputCells().size();
		MPI_Send(&numberOfCellsFromThisRank, 1, MPI_UNSIGNED, _processingRank, 0, _comm);

		//Send that many cells (and indices)
		for(unsigned int c = 0; c < numberOfCellsFromThisRank; c++) { //TODO: send all cells at once
			//fill buffers
			macroscopicCellToBuffer(_cellbuf, _filter->getInputCells()[c]);

			//send cell
			MPI_Send(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, _processingRank, 0, _comm);
		}

		//The processing rank now processes...

		//Receive output data
		for(unsigned int c = 0; c < numberOfCellsFromThisRank; c++) { //TODO: receive all cells at once
			//receive cell
			MPI_Recv(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, _processingRank, 0, _comm, MPI_STATUS_IGNORE);

			//find cell in filter's domain and apply
			bufferToMacroscopicCell(_cellbuf, _filter->getOutputCells()[c]);
		}
	}
}


template<unsigned int dim>
void coupling::filtering::SequentialFilter<dim>::process(bool sequential) {
	if(sequential) {
		_filter->updateCellData(_inputCells_Global, _outputCells_Global);
	}

	#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): Now applying filter..." << std::endl;
	#endif

	//Apply _filter
	(*_filter)();

	#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): ...done applying filter." << std::endl;
	#endif

	if(sequential) {
		//Now ready to distribute data back to the data's original ranks...
		for(unsigned int c = 0, localCellsUpdated = 0; c < _outputCells_Global.size(); c++) {
			//fill buffers with cell data
			macroscopicCellToBuffer(_cellbuf, _outputCells_Global[c]);

			//get rank of cell
			const auto is = coupling::indexing::IndexingService<dim>::getInstance();
			//TODO: use getUniqueRank instead
			int target_rank = static_cast<int>(is.getRanksForGlobalIndex(coupling::indexing::CellIndex<dim> { c })[0]);
				
			#ifdef DEBUG_SEQ_FILTER_VERBOSE
				std::cout << "		SEQFILTER (" << _myRank << "): Sending cell " << c << " to rank " << target_rank << std::endl;
			#endif

			//Case: cell belongs to this rank, no communication needed	
			if(target_rank == _processingRank) {
				bufferToMacroscopicCell(_cellbuf, _outputCells_Local[localCellsUpdated]);
				localCellsUpdated++;

				#ifdef DEBUG_SEQ_FILTER_VERBOSE
					std::cout << "		SEQFILTER (" << _myRank << "): Wrote cell " << c << " to local cell." << std::endl;
				#endif
			}
			//Case: other rank, we need to send cell and index
			else {
				//send cell
				MPI_Send(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, target_rank, 0, _comm);
			}
		}

		//Re-update _filter's internal member variables in order to ensure proper functionality of filters after this one, i.e. make getOutputVector() work as expected.
		_filter->updateCellData(_inputCells_Local, _outputCells_Local);
	}
}


template<unsigned int dim>
void coupling::filtering::SequentialFilter<dim>::macroscopicCellToBuffer(std::vector<double>& buf, const coupling::datastructures::MacroscopicCell<dim>* cell){
	//Resize if buffer is too small to contain cell data
	if(buf.capacity() < 4+3*dim) {
		buf.resize(4+3*dim); 
		#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): Cell buffer resized to: " << buf.size() << std::endl;
		#endif
	}

	//copy cell data to buffer
	unsigned int i = 0;
	/*micro mass*/ 		buf[i] = cell->getMicroscopicMass(); i++; //std::cout << buf.back() << " ";
	/*micro momentum*/	for (unsigned d = 0; d < dim; d++) { buf[i] = cell->getMicroscopicMomentum()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*macro mass*/		buf[i] = cell->getMacroscopicMass(); i++; //std::cout << buf.back() << " ";
	/*macro momentum*/	for (unsigned d = 0; d < dim; d++) { buf[i] = cell->getMacroscopicMomentum()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*pot energy*/		buf[i] = cell->getPotentialEnergy(); i++; //std::cout << buf.back() << " ";
	/*velocity*/		for (unsigned d = 0; d < dim; d++) { buf[i] = cell->getCurrentVelocity()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*temperature*/		buf[i] = cell->getTemperature(); i++; //std::cout << buf.back() << " ";
	//std::cout << std::endl;
}


template<unsigned int dim>
void coupling::filtering::SequentialFilter<dim>::bufferToMacroscopicCell(const std::vector<double>& buf, coupling::datastructures::MacroscopicCell<dim>* cell) {
	if(buf.capacity() < 4+3*dim) throw std::runtime_error("Buffer too small for cell data!");

	tarch::la::Vector<dim, double> mvec_buf;
	unsigned int i = 0;
	//copy buffer data to cell
	/*micro mass*/ 		cell->setMicroscopicMass(buf[i]); i++;
	/*micro momentum*/	for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell->setMicroscopicMomentum(mvec_buf);
	/*macro mass*/		cell->setMacroscopicMass(buf[i]); i++;
	/*macro momentum*/	for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell->setMacroscopicMomentum(mvec_buf);
	/*pot energy*/		cell->setPotentialEnergy(buf[i]); i++;
	/*velocity*/		for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell->setCurrentVelocity(mvec_buf);
	/*temperature*/		cell->setTemperature(buf[i]); i++;
	//std::cout << cell << std::endl;
}
