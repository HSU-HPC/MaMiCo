// This file is part of_outputCells_Localconditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico


//Implementation of SequentialFilter.h

//TODO: implement getOutputCellOfIndex() function in FI!

//CONSTRUCTOR
template <unsigned int dim>
coupling::SequentialFilter<dim>::SequentialFilter(
	coupling::FilterInterface<dim>* filter,
	const coupling::IndexConversionMD2Macro<dim>* ic, //null if run locally i.e. parallel
	const MPI_Comm comm //null if run locally i.e. parallel
	):
	coupling::FilterInterface<dim>("SEQUENTIALIZED_FILTER"),
	_filter(filter),
	_ic(ic),
	_comm(comm),
	_processingRank(0), //TODO: Make this customizable.
	_myRank((int) _ic->getBaseIC()->getThisRank()),
	_firstIteration(false)
{
	#ifdef DEBUG_SEQ_FILTER
	std::cout << "		SEQFILTER (" << _myRank << "): Now initializing sequentialized Filter of type: " << _filter->getType() <<std::endl;
	#endif

	//init buffers to prevent later segfaults when calling data() on them
	_cellbuf = {};
	_indexbuf = {};

	//case: sequential
	if(_ic) {
		MPI_Comm_size(comm, &_commSize);	

		//allocate global cell data structures for processing rank only
		if( _processingRank == _myRank) {
			_inputCells_Local = _filter->getInputCells(); //filter's input cell pointers will be overwritten, but we need this information in contribute()
			_outputCells_Local = _filter->getOutputCells(); //filter's output cell pointers will be overwritten, but we need this information in process()

			//Update filter's original cell data

			//TODO: do this using IC, not all cells with have same amount
			for(int c = 0; c < _outputCells_Local.size() * _commSize; c++) {
				_inputCells_Global.push_back(new coupling::datastructures::MacroscopicCell<dim>());
				_outputCells_Global.push_back(new coupling::datastructures::MacroscopicCell<dim>());
			}
			
			//Reserve space in global index vector. Indices will be communicated using MPI.
			_cellIndices_Global.reserve(_inputCells_Local.size());

		}//if rank processing rank
	}//if sequential

	//case: not sequential
	else {
		_commSize = 1;
		#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): It will not run sequentially." << std::endl;
		#endif
	}
}

//MEMBER FUNCTIONS
template<unsigned int dim>
void coupling::SequentialFilter<dim>::operator()(){
	if(_ic) {
		if(_processingRank == _myRank) {
			contribute();
			process(FILTER_SEQUENTIAL);
		}
		else contribute();
	}
	else process(FILTER_PARALLEL);
}

		
//PRIVATE FUNCTIONS
template<unsigned int dim>
void coupling::SequentialFilter<dim>::contribute() {	
	#ifdef DEBUG_SEQ_FILTER
	std::cout << "		SEQFILTER (" << _myRank << "): Sending cells and indices." << std::endl;
	#endif

	//TODO

	if(_firstIteration) {
		_filter->updateCellData(_inputCells_Global, _outputCells_Global, _cellIndices_Global);
		_firstIteration = false;
	}


	#ifdef DEBUG_SEQ_FILTER
	if(_processingRank == _myRank) {
		std::cout << "		SEQFILTER (" << _myRank << "): Received cells and indices." << std::endl;
	}
	#endif

	//Receive output data
	if(_processingRank != myRank) {
		for(unsigned int cell_count = 0; cell_count < _filter->getOutputCells().size(); cell_count++) {
			//receive cell
			MPI_Receive(_cellbuf.data(), _cellbuf.size(), MPI_DOUBLE, _processingRank, 0, _comm, MPI_STATUS_IGNORE);
			//receive corresponding index
			MPI_Receive(_indexbuf.data(), _indexbuf.size(), MPI_UNSIGNED, _processingRank, 0, _comm, MPI_STATUS_IGNORE);
			
			//find cell in filter's domain and apply
			tarch::la::Vector<unsigned int, dim> receivedIndex;
			bufferToCellIndex(_indexbuf, receivedIndex);
			bufferToMacroscopicCell(_cellbuf, _filter->getOutputCellOfIndex(receivedIndex));
		}
	}
}

template<unsigned int dim>
void coupling::SequentialFilter<dim>::process(bool sequential) {
			//these are either local or global
			if(sequential) {

				//Apply _filter
				(*_filter)();

				//Now ready to distribute data back to the data's original ranks...
				for(unsigned int c = 0; c < _outputCells_Global.size(); c++) {
					//fill buffer with cell data
					macroscopicCellToBuffer(_cellbuf, _outputCells_Global[c]);

					//get rank of cell
					int target_rank = 0 //TODO use IC or something
				
					//Case: cell belongs to this rank, no communication needed	
					if(target_rank == _processingRank) {
						bufferToMacroscopicCell(_cellbuf, _filter->getOutputCellOfIndex(_cellIndices_Global[c]));
					}
					//Case: other rank, we need to send cell and index
					else {
						//send cell
						MPI_Send(_cellbuf.data(), _cellbuf.size(), MPI_DOUBLE, target_rank, 0, _comm);
						//send corresponding index
						MPI_Send(_indexbuf.data(), _indexbuf.size(), MPI_UNSIGNED, target_rank, 0, _comm);
					}
				}
			}
			else {
				(*_filter)();
			}
		}



template<unsigned int dim>
void coupling::SequentialFilter<dim>::macroscopicCellToBuffer(std::vector<double>& buf, const coupling::datastructures::MacroscopicCell<dim>* cell){
	std::cout << "		SEQFILTER (" << _myRank << "): MCTB: Buffer size: " << buf.size() << std::endl;
	if(cells.empty()) std::cout << "		SEQFILTER (" << _myRank << "): MCTB: Warning: empty cell vector.";

	//Resize if buffer is too small to contain all cell data
	if(buf.capacity() < 4+3*dim) {
		buf.resize(4+3*dim); 
		std::cout << "		SEQFILTER (" << _myRank << "): MCTB: buf resized to: " << buf.size() << std::endl;
	}
		

	//copy cell data to buffer
	unsigned i = 0;
	/*micro mass*/ 		buf[i] = cell->getMicroscopicMass(); i++; //std::cout << buf.back() << " ";
	/*micro momentum*/	for (unsigned d = 0; d < dim; d++) { buf[i] = cell->getMicroscopicMomentum()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*macro mass*/		buf[i] = cell->getMacroscopicMass(); i++; //std::cout << buf.back() << " ";
	/*macro momentum*/	for (unsigned d = 0; d < dim; d++) { buf[i] = cell->getMacroscopicMomentum()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*pot energy*/		buf[i] = cell->getPotentialEnergy(); i++; //std::cout << buf.back() << " ";
	/*velocity*/		for (unsigned d = 0; d < dim; d++) { buf[i] = cell->getCurrentVelocity()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*temperature*/		buf[i] = cell->getTemperature(); i++; //std::cout << buf.back() << " ";
	//std::cout << std::endl;
	}
}	


template<unsigned int dim>
void coupling::SequentialFilter<dim>::bufferToMacroscopicCell(const std::vector<double>& buf, coupling::datastructures::MacroscopicCell<dim>* cell) {
	std::cout << "		SEQFILTER (" << _myRank << "): BTMC: Buffer size: " << buf.size() << std::endl;
	if(buf.capacity() < 4+3*dim) throw std::runtime_error("Buffer too small for cell data!");

	tarch::la::Vector<dim, double> mvec_buf;
	unsigned int i = 0;
	//copy buffer data to cell
	/*micro mass*/ 		cell->setMicroscopicMass(buf[i]); i++;
	/*micro momentum*/	for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell->setMicroscopicMomentum(mvec_buf);
	/*macro mass*/		cell->setMacroscopicMass(buf[i]); i++;
	/*macro momentum*/	for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell->setMacroscopicMomentum(mvec_buf);
	/*pot energy*/		cell->setPotentialEnergy(buf[i]); i++;
	/*velocity*/		for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell->setCurrentVelocity(mvec_buf);
	/*temperature*/		cell->setTemperature(buf[i]); i++;
	//std::cout << cell << std::endl;
	}
}


void coupling::SequentialFilter<dim>::cellIndexToBuffer(std::vector<unsigned int>& buf, const tarch::la::Vector<dim, unsigned int>* index) {
	if(buf.capacity() < dim) buf.reserve(dim);
	for(unsigned int d = 0; d<dim; d++) buf[d] = index[d];
}

void coupling::SequentialFilter<dim>::bufferToCellIndex(const std::vector<unsigned int>& buf, tarch::la::Vector<dim, unsigned int>* index) {
	for(unsigned int d = 0; d<dim; d++) index[d] = buf[d];
}
