// This file is part of_outputCells_Localconditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico


//Implementation of SequentialFilter.h


//CONSTRUCTOR
template <unsigned int dim>
coupling::SequentialFilter<dim>::SequentialFilter(
	coupling::FilterInterface<dim>* filter,
	const MPI_Comm comm
	):
	coupling::FilterInterface<dim>("SEQUENTIALIZED_FILTER"),
	_filter(filter),
	_comm(comm),
	_processingRank(0) //TODO: Make this customizable.
{
	#ifdef DEBUG_SEQ_FILTER
	std::cout << "		SEQFILTER (" << _myRank << "): Now initializing sequentialized Filter of type: " << _filter->getType() <<std::endl;
	#endif

	//init buffers to prevent later segfaults when calling data() on them
	_cellbuf = {};
	_indexbuf = {};

	//init communicator size and _myRank
	MPI_Comm_size(comm, &_commSize);	
	MPI_Comm_rank(comm, &_myRank);

	//allocate global cell data structures for processing rank only
	if( _processingRank == _myRank) { [[unlikely]]
		//_filter's input cell pointers will be overwritten, but we need this information in contribute()
		_inputCells_Local = _filter->getInputCells(); 
		_outputCells_Local = _filter->getOutputCells(); 			

		//Get linear domain size, i.e amount of cells in domain. Can probably be done more elegantly using base IC.
		unsigned int domainSizeLinear = 1;
		for(unsigned int d = 0; d < dim; d++) 
			domainSizeLinear *= coupling::indexing::CellIndex<dim, {.local=false, .md2macro=true}>::numberCellsInDomain[d];

		//allocate global cells
		for(unsigned int c = 0; c < domainSizeLinear ; c++) { 
			_inputCells_Global.push_back(new coupling::datastructures::IndexedMacroscopicCell<dim> { });
			_outputCells_Global.push_back(new coupling::datastructures::IndexedMacroscopicCell<dim> { });
		}
	}

	//Resize if buffers are too small to contain cell data
	if(_cellbuf.capacity() < 4+3*dim) {
		_cellbuf.resize(4+3*dim); 
		#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): Cell buffer resized to: " << _cellbuf.size() << std::endl;
		#endif
	}
	//Resize if index buffer is too small to contain a dim-dimensional (raw unsigned int) index
	if(_indexbuf.capacity() < dim) {
		_indexbuf.resize(dim); 
		#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): Index buffer resized to: " << _indexbuf.size() << std::endl;
		#endif
	}
}

//MEMBER FUNCTIONS
template<unsigned int dim>
void coupling::SequentialFilter<dim>::operator()(){	
	contribute();

	if(_processingRank == _myRank) [[unlikely]]
		process();
}

template<unsigned int dim>
coupling::datastructures::IndexedMacroscopicCell<dim>* coupling::SequentialFilter<dim>::getLocalInputCellOfIndex(const coupling::indexing::CellIndex<dim> index) const {
	for(const auto c : _inputCells_Local) 
		if(index == c->index) [[unlikely]] return c; 

	throw std::runtime_error("SequentialFilter: getLocalInputCellofIndex(): Could not find index.");
}
		
template<unsigned int dim>
coupling::datastructures::IndexedMacroscopicCell<dim>* coupling::SequentialFilter<dim>::getLocalOutputCellOfIndex(const coupling::indexing::CellIndex<dim> index) const {
	for(const auto c : _outputCells_Local) 
		if(index == c->index) [[unlikely]] return c; 

	throw std::runtime_error("SequentialFilter: getLocalOutputCellofIndex(): Could not find index.");
}

		
//PRIVATE FUNCTIONS
template<unsigned int dim>
void coupling::SequentialFilter<dim>::contribute() {	
	#ifdef DEBUG_SEQ_FILTER
	std::cout << "		SEQFILTER (" << _myRank << "): Sending cells and indices." << std::endl;
	#endif

	if(_processingRank == _myRank) [[unlikely]] {
		//Count cells that we update. This should be equal to _inputCells_Global.size().
		unsigned int cellsUpdated = 0;
		
		//Iteratate over all (contributing) ranks...
		for(int rank = 0; rank < _commSize; rank++) { //TODO: allow arbitrary comms: with ranks < _commSize that are not in _comm

			//Case: The contributing rank is the processing rank. In this case, we only need to copy cell data.
			if(rank == _myRank) {
				#ifdef DEBUG_SEQ_FILTER
					std::cout << "		SEQFILTER (" << _myRank << "): Copying " << _inputCells_Local.size() << " cells from local on processing rank " << rank << std::endl;
				#endif

				//Copy all cell data to global data structures.
				for(unsigned int c = 0; c < _inputCells_Local.size(); c++) {
					*(_inputCells_Global[cellsUpdated]) = *(_inputCells_Local[c]);
					cellsUpdated++;
				}

				#ifdef DEBUG_SEQ_FILTER
					std::cout << "		SEQFILTER (" << _myRank << "): Copied a total of " << cellsUpdated << " cells." << std::endl;
				#endif
			}

			//Case: the contributing rank is not the processing rank. We need to communicate cell data using MPI.
			else {
				//Receive number of indexed cells that will be sent from that rank
				unsigned int numberOfCellsFromRank;
				MPI_Recv(&numberOfCellsFromRank, 1, MPI_UNSIGNED, rank, 0, _comm, MPI_STATUS_IGNORE);
				#ifdef DEBUG_SEQ_FILTER
				std::cout << "		SEQFILTER (" << _myRank << "): Expecting a total of " << numberOfCellsFromRank << " cells and indices from rank " << rank << std::endl;
				#endif

				//Receive that many indexed cells
				for(unsigned int c = 0; c < numberOfCellsFromRank; c++) {
					//receive cell
					MPI_Recv(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, rank, 0, _comm, MPI_STATUS_IGNORE);
					//receive corresponding index
					MPI_Recv(_indexbuf.data(), dim, MPI_UNSIGNED, rank, 0, _comm, MPI_STATUS_IGNORE);

					//std::cout << "Seqfilter 172:" << c << ": " << _indexbuf[0] << ", " << _indexbuf[1] << ", " << _indexbuf[2] << std::endl;

					//Insert data received into global (indexed) cell data structures
					bufferToMacroscopicCell(_cellbuf, _inputCells_Global[cellsUpdated]->cell);
					bufferToCellIndex<{.local=false}>(_indexbuf, _inputCells_Global[cellsUpdated]->index);
					
					cellsUpdated++;

					#ifdef DEBUG_SEQ_FILTER_VERBOSE
					std::cout << "			SEQFILTER (" << _myRank << "): Received cell and index (" << rank << ") from rank " << rank << std::endl;
					#endif

				}

			}
			#ifdef DEBUG_SEQ_FILTER
			std::cout << "		SEQFILTER (" << _myRank << "): Received cells and indices from rank " << rank << std::endl;
			#endif
		}	

		//TODO: Assert cellsUpdated == inputCells_Global.size()

		//This rank now processes...

	} //end: if _myRank == processingRank
	else /* non-processing, i.e. contributing, rank */{
		
		//Communicate to processing rank how many cells+indices will be send
		unsigned int numberOfCellsFromThisRank = _filter->getInputCells().size();
		MPI_Send(&numberOfCellsFromThisRank, 1, MPI_UNSIGNED, _processingRank, 0, _comm);

		//Send that many cells (and indices)
		for(const coupling::datastructures::IndexedMacroscopicCell<dim>* c : _filter->getInputCells()) { 
			//fill buffers
			macroscopicCellToBuffer(_cellbuf, c->cell);
			cellIndexToBuffer<{.vector=true, .local=false}>(_indexbuf, c->index);

			//send cell
			MPI_Send(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, _processingRank, 0, _comm);
			//send corresponding index
			MPI_Send(_indexbuf.data(), dim, MPI_UNSIGNED, _processingRank, 0, _comm);
		}

		//The processing rank now processes...

		//Receive output data
		for(unsigned int c = 0; c < numberOfCellsFromThisRank; c++) { //TODO: use advanced for loop here as well?
			//receive cell
			MPI_Recv(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, _processingRank, 0, _comm, MPI_STATUS_IGNORE);
			//receive corresponding index
			MPI_Recv(_indexbuf.data(), 3, MPI_UNSIGNED, _processingRank, 0, _comm, MPI_STATUS_IGNORE);
			
			//construct (global) CellIndex object from buffer
			coupling::indexing::CellIndex<dim, {.local=false}> globalCellIndex{ };
			bufferToCellIndex<{.local=false}>(_indexbuf, globalCellIndex); //TODO: automatic template deduction?

			//find cell in filter's domain and apply.
			for(coupling::datastructures::IndexedMacroscopicCell<dim>* oc : _filter->getOutputCells())
				if (oc->index == globalCellIndex) [[unlikely]] bufferToMacroscopicCell(_cellbuf, oc->cell);
		}
	}
}


template<unsigned int dim>
void coupling::SequentialFilter<dim>::process() {
	_filter->updateCellData(_inputCells_Global, _outputCells_Global);

	#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): Now applying filter..." << std::endl;
	#endif

	//Apply _filter
	(*_filter)();

	#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): ...done applying filter." << std::endl;
	#endif

	//Now ready to distribute data back to the data's original ranks...
	for(const coupling::datastructures::IndexedMacroscopicCell<dim>* c : _outputCells_Global) {
		
		//get rank of cell
		int target_rank = 0;//TODO 
				
		#ifdef DEBUG_SEQ_FILTER_VERBOSE
			std::cout << "		SEQFILTER (" << _myRank << "): Sending cell of index " << _cellIndices_Global[c] << " to rank " << target_rank << std::endl;
		#endif

		//Case: cell belongs to this rank, no communication needed	
		if(target_rank == _processingRank) {
			*getLocalOutputCellOfIndex(c->index) = *c;

			#ifdef DEBUG_SEQ_FILTER_VERBOSE
				std::cout << "		SEQFILTER (" << _myRank << "): Wrote cell of index " << _cellIndices_Global[c] << " to local cell at " << getLocalOutputCellOfIndex(_cellIndices_Global[c]) << std::endl;
			#endif
		}
		//Case: other rank, we need to send cell and index
		else {
			//fill buffers with cell data
			macroscopicCellToBuffer(_cellbuf, c->cell);
			cellIndexToBuffer<{.vector=true, .local=false}>(_indexbuf, c->index); //TODO: automatic template deduction?

			//send cell
			MPI_Send(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, target_rank, 0, _comm);
			//send corresponding index
			MPI_Send(_indexbuf.data(), 3, MPI_UNSIGNED, target_rank, 0, _comm);
		}
	}

	//Re-update _filter's internal member variables in order to ensure proper functionality of filters after this one, i.e. make getOutputVector() work as expected.
	_filter->updateCellData(_inputCells_Local, _outputCells_Local);
}


template<unsigned int dim>
void coupling::SequentialFilter<dim>::macroscopicCellToBuffer(std::vector<double>& buf, const coupling::datastructures::MacroscopicCell<dim>& cell) const {
	//Resize if buffer is too small to contain cell data
	if(buf.capacity() < 4+3*dim) {
		buf.resize(4+3*dim); 
		#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): Cell buffer resized to: " << buf.size() << std::endl;
		#endif
	}

	//copy cell data to buffer
	unsigned int i = 0;
	/*micro mass*/ 		buf[i] = cell.getMicroscopicMass(); i++; //std::cout << buf.back() << " ";
	/*micro momentum*/	for (unsigned d = 0; d < dim; d++) { buf[i] = cell.getMicroscopicMomentum()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*macro mass*/		buf[i] = cell.getMacroscopicMass(); i++; //std::cout << buf.back() << " ";
	/*macro momentum*/	for (unsigned d = 0; d < dim; d++) { buf[i] = cell.getMacroscopicMomentum()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*pot energy*/		buf[i] = cell.getPotentialEnergy(); i++; //std::cout << buf.back() << " ";
	/*velocity*/		for (unsigned d = 0; d < dim; d++) { buf[i] = cell.getCurrentVelocity()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*temperature*/		buf[i] = cell.getTemperature(); i++; //std::cout << buf.back() << " ";
	//std::cout << std::endl;
}


template<unsigned int dim>
void coupling::SequentialFilter<dim>::bufferToMacroscopicCell(const std::vector<double>& buf, coupling::datastructures::MacroscopicCell<dim>& cell) const {
	if(buf.capacity() < 4+3*dim) throw std::runtime_error("Buffer too small for cell data!");

	tarch::la::Vector<dim, double> mvec_buf;
	unsigned int i = 0;
	//copy buffer data to cell
	/*micro mass*/ 		cell.setMicroscopicMass(buf[i]); i++;
	/*micro momentum*/	for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell.setMicroscopicMomentum(mvec_buf);
	/*macro mass*/		cell.setMacroscopicMass(buf[i]); i++;
	/*macro momentum*/	for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell.setMacroscopicMomentum(mvec_buf);
	/*pot energy*/		cell.setPotentialEnergy(buf[i]); i++;
	/*velocity*/		for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell.setCurrentVelocity(mvec_buf);
	/*temperature*/		cell.setTemperature(buf[i]); i++;
}


template<unsigned int dim>
template<coupling::indexing::IndexType idx_T>
void coupling::SequentialFilter<dim>::cellIndexToBuffer(std::vector<unsigned int>& buf, const coupling::indexing::CellIndex<dim, idx_T>& index) const {
	if(buf.capacity() < dim) buf.reserve(dim);
	if constexpr (idx_T.vector) {
		for(unsigned int d = 0; d<dim; d++) buf[d] = index.get()[d];
	}
	else {
		const auto index_vec = (coupling::indexing::CellIndex<dim, {true, idx_T.local, idx_T.md2macro, idx_T.noGhost}>) index;
		for(unsigned int d = 0; d<dim; d++) buf[d] = index_vec.get()[d];
	}
}


template<unsigned int dim>
template<coupling::indexing::IndexType idx_T>
void coupling::SequentialFilter<dim>::bufferToCellIndex(const std::vector<unsigned int>& buf, coupling::indexing::CellIndex<dim, idx_T>& index) const {
	tarch::la::Vector<dim, unsigned int> buf_raw {};
	for(unsigned int d = 0; d<dim; d++) buf_raw[d] = buf[d];
	
	if constexpr(idx_T.vector) {
		//call primitive constructor of vector index
		index = { buf_raw };
	}
	else {
		//call user-defined conversion: vector -> non-vector
		index = { coupling::indexing::CellIndex<dim, {true, idx_T.local, idx_T.md2macro, idx_T.noGhost}> { buf_raw } };
	}
}
