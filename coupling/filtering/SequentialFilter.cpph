// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico


//Implementation of SequentialFilter.h

template <unsigned int dim>
coupling::SequentialFilter<dim>::SequentialFilter(
	coupling::FilterInterface<dim>* filter,
	const coupling::IndexConversionMD2Macro<dim>* ic, //null if run locally i.e. parallel
	const MPI_Comm comm //null if run locally i.e. parallel TODO: in case of multimd, this goes very wrong
	):
	coupling::FilterInterface<dim>("SEQUENTIALIZED_FILTER"),
	_filter(filter),
	_ic(ic),
	_comm(comm),
	_processingRank(0), //TODO: case: multimd
	_cellsPerRank(_filter->getSize()),
	_firstIteration(true)
{
	#ifdef DEBUG_SEQ_FILTER
	std::cout << "		SEQFILTER: Now initializing sequentialized Filter of type: " << _filter->getType() <<std::endl;
	#endif

	//case: sequential
	if((*_ic)()) {
		MPI_Comm_size(comm, &_commSize);	

		//allocate global cell data structures for processing rank only
		if( _processingRank == (int) (*_ic)()->getThisRank()) {
			_outputCells_Local = _filter->getOutputCells(); //filter's output cell pointers will be overwritten, but we need this information in operator()

			for(int c = 0; c < _cellsPerRank * _commSize; c++) {
				_inputCells_Global.push_back(new coupling::datastructures::MacroscopicCell<dim>());
				_outputCells_Global.push_back(new coupling::datastructures::MacroscopicCell<dim>());
			}

			//fill global indexing vector. Assumes dim >= 1.
					
			//TODO: assert: //_cellsPerRank * _commSize == _ic->getGlobalMD2MacroDomainSize()[0]) * ... * _ic->getGlobalMD2MacroDomainSize()[dim-1])

			unsigned int indexBuffer[dim] = {0};
			for(int c = 0; c < _cellsPerRank * _commSize; c++) {
				//TODO: make indexBuffer a tarch::la::Vector for easier initialisation of this	
				//addition of new index	
				_cellIndices_Global.push_back(tarch::la::Vector<dim, unsigned int>(0));
				for(unsigned int d = 0; d < dim; d++) _cellIndices_Global.back()[d] = indexBuffer[d];

				//update of indexBuffer
				indexBuffer[0]++;
				if(indexBuffer[0] == _ic->getGlobalMD2MacroDomainSize()[0]) {
					indexBuffer[0] = 0;
					//if dim = 0, you should not be able to reach this, so this should(tm) never segfault
					indexBuffer[1]++;
				}
				//TODO: test this
				//this should not concern d = dim-1 as long as above assertion is met
				for(unsigned int d = 1; d < dim-1; d++) {
					//in this case, both the previous and this dimension hit their maximum
					if(indexBuffer[d] == _ic->getGlobalMD2MacroDomainSize()[d]) {
						indexBuffer[d] = 0; 
						indexBuffer[d+1] += 1;
					}
					else break;
				}//for dim
			}//for cell
		}//if rank processing rank
	}//if sequential

	//case: not sequential
	else {
		_commSize = 0;
		#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER: It will not run sequentially." << std::endl;
		#endif
	}
}
		

template<unsigned int dim>
void coupling::SequentialFilter<dim>::contribute() {
			//TODO: 95% sure this is deprecated
			/*
			//communicate indices during first iteration
			if(_firstIteration == true) {
				std::vector<unsigned int> indexbuf;
				std::vector<unsigned int> indexrecvbuf; //accessed only by processing rank

				//TODO: performance can be improved
				for(int i_local = 0; i_local < _cellsPerRank; i_local++){
					//we dont actually use global cell indices, this is just a way to compress data
					indexbuf.push_back((*_ic)()->getGlobalCellIndex(_filter->getCellIndices()[i_local]));
				}
				if( _processingRank == (int) (*_ic)()->getThisRank()) indexrecvbuf.resize(_cellsPerRank * _commSize);

				//gather all linear indices at processing rank
				MPI_Gather(indexbuf.data(), _cellsPerRank, MPI_UNSIGNED, indexrecvbuf.data(), _cellsPerRank * _commSize, MPI_UNSIGNED, _processingRank, _comm); 

				//Parse to _cellIndices_Global
				if( _processingRank == (int) (*_ic)()->getThisRank())
				for(int i_global = 0; i_global < (int) indexrecvbuf.size(); i_global++)
					//revert compression to linear index
					_cellIndices_Global.push_back((*_ic)()->getGlobalVectorCellIndex(indexrecvbuf[i_global]));
				
				//for(auto index : _cellIndices_Global) std::cout << index << std::endl;

				_firstIteration = false;
			}*/

	//construct MacroscopicCell buffer from input cell vector
	macroscopicCellsToBuffer(_sendbuf, _filter->getInputCells());

	#ifdef DEBUG_SEQ_FILTER
	std::cout << "		SEQFILTER: Sending buffer of size: " << _sendbuf.size() << std::endl;
	#endif

	//TODO: unneccesary to do this in each iteration
	//allocate on processing rank
	if(_processingRank == (int) (*_ic)()->getThisRank()) _recvbuf.resize(_sendbuf.size()*_commSize);
	
	//send to processing rank 
	MPI_Gather(_sendbuf.data(), _sendbuf.size(), MPI_DOUBLE, _recvbuf.data(), _sendbuf.size() * _commSize, MPI_DOUBLE, _processingRank, _comm); 

	#ifdef DEBUG_SEQ_FILTER
	if(_processingRank == (int) (*_ic)()->getThisRank()) std::cout << "		SEQFILTER: Receiving buffer of size: " << _recvbuf.size() << std::endl;
	#endif
}


template<unsigned int dim>
void coupling::SequentialFilter<dim>::macroscopicCellsToBuffer(std::vector<double>& buf, const std::vector<coupling::datastructures::MacroscopicCell<dim> *>& cells){
	if(cells.empty()) std::cout << "		SEQFILTER: MCTB: Warning: empty cell vector.";

	//copy cell data to buffer
	for(auto cell : cells) {
		buf.push_back(cell->getMicroscopicMass()); //std::cout << buf.back() << " ";
		for (unsigned d = 0; d < dim; d++) { buf.push_back(cell->getMicroscopicMomentum()[d]); /*std::cout << buf.back() << " ";*/ } 
		buf.push_back(cell->getMacroscopicMass()); //std::cout << buf.back() << " ";
		for (unsigned d = 0; d < dim; d++) { buf.push_back(cell->getMacroscopicMomentum()[d]); /*std::cout << buf.back() << " ";*/ } 
		buf.push_back(cell->getPotentialEnergy()); //std::cout << buf.back() << " ";
		for (unsigned d = 0; d < dim; d++) { buf.push_back(cell->getCurrentVelocity()[d]); /*std::cout << buf.back() << " ";*/ } 
		buf.push_back(cell->getTemperature()); //std::cout << buf.back() << " ";
		//std::cout << std::endl;
	}
}	


template<unsigned int dim>
void coupling::SequentialFilter<dim>::applyBufferToMacroscopicCells(std::vector<double>& buf, const std::vector<coupling::datastructures::MacroscopicCell<dim> *>& cells) {
	std::cout << "		SEQFILTER: ABTMC: Buffer size: " << buf.size() << " Cell vector size: " << cells.size() << std::endl;
	if(buf.size() != cells.size() * (4+3*dim) ) throw std::runtime_error("Buffer and cell vector size must be the same!"); //TODO

	//copy buffer data to cells
	tarch::la::Vector<dim, double> mvec_buf;
	unsigned int i = 0;
	for(unsigned int c = 0; c < cells.size(); c++) {
		cells[c]->setMicroscopicMass(buf[i]); i++;
		for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cells[c]->setMicroscopicMomentum(mvec_buf);
		cells[c]->setMacroscopicMass(buf[i]); i++;
		for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cells[c]->setMacroscopicMomentum(mvec_buf);
		cells[c]->setPotentialEnergy(buf[i]); i++;
		for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cells[c]->setCurrentVelocity(mvec_buf);
		cells[c]->setTemperature(buf[i]); i++;
	}
}
