// This file is part of_outputCells_Localconditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico


//Implementation of SequentialFilter.h


//CONSTRUCTOR
template <unsigned int dim>
coupling::SequentialFilter<dim>::SequentialFilter(
	coupling::FilterInterface<dim>* filter,
	const coupling::IndexConversionMD2Macro<dim>* ic, //null if run locally i.e. parallel
	const MPI_Comm comm //null if run locally i.e. parallel
	):
	coupling::FilterInterface<dim>("SEQUENTIALIZED_FILTER"),
	_filter(filter),
	_ic(ic),
	_comm(comm),
	_processingRank(0), //TODO: Make this customizable.
	_myRank((int) _ic->getBaseIC()->getThisRank()),
	_firstIteration(false)
{
	#ifdef DEBUG_SEQ_FILTER
	std::cout << "		SEQFILTER (" << _myRank << "): Now initializing sequentialized Filter of type: " << _filter->getType() <<std::endl;
	#endif

	//init buffers to prevent later segfaults when calling data() on them
	_cellbuf = {};
	_indexbuf = {};

	//case: sequential
	if(_ic) {
		MPI_Comm_size(comm, &_commSize);	

		//allocate global cell data structures for processing rank only
		if( _processingRank == _myRank) {
			//filter's input cell pointers will be overwritten, but we need this information in contribute()
			_inputCells_Local = _filter->getInputCells(); 
			_outputCells_Local = _filter->getOutputCells(); 			
			_cellIndices_Local = _filter->getCellIndices(); 

			//Get linear domain size, i.e amount of cells in domain. Can probably be done more elegantly using base IC.
			auto domainSizeVector = _ic->getGlobalMD2MacroDomainSize();
			unsigned int domainSizeLinear = 1;
			for(unsigned int d = 0; d < dim; d++) domainSizeLinear *= domainSizeVector[d];
			for(unsigned int c = 0; c < domainSizeLinear ; c++) { //TODO: double check if this is the correct function. "global" ambiguity fixed?
				_inputCells_Global.push_back(new coupling::datastructures::MacroscopicCell<dim>());
				_outputCells_Global.push_back(new coupling::datastructures::MacroscopicCell<dim>());
			}
			
			//Reserve space in global index vector. Indices will be communicated using MPI.
			_cellIndices_Global.reserve(_inputCells_Global.size());

		}//if rank processing rank
	}//if sequential

	//case: not sequential
	else {
		_commSize = 1;
		#ifdef DEBUG_SEQ_FILTER
		std::cout << "		SEQFILTER (" << _myRank << "): It will not run sequentially." << std::endl;
		#endif
	}
}

//MEMBER FUNCTIONS
template<unsigned int dim>
void coupling::SequentialFilter<dim>::operator()(){
	if(_ic) {
		if(_processingRank == _myRank) {
			contribute();
			process(FILTER_SEQUENTIAL);
		}
		else contribute();
	}
	else process(FILTER_PARALLEL);
}


template<unsigned int dim>
coupling::datastructures::MacroscopicCell<dim>* coupling::SequentialFilter<dim>::getLocalInputCellOfIndex(tarch::la::Vector<dim,unsigned int> index) {
	for(unsigned int i = 0; i < _cellIndices_Local.size(); i++) {
		if(_cellIndices_Local[i] == index) return _inputCells_Local[i];
	}
	throw std::runtime_error("SequentialFilter: getLocalInputCellofIndex(): Could not find index.");
}
		

template<unsigned int dim>
coupling::datastructures::MacroscopicCell<dim>* coupling::SequentialFilter<dim>::getLocalOutputCellOfIndex(tarch::la::Vector<dim,unsigned int> index) {
	for(unsigned int i = 0; i < _cellIndices_Local.size(); i++) {
		if(_cellIndices_Local[i] == index) return _outputCells_Local[i];
	}
	throw std::runtime_error("SequentialFilter: getLocalOutputCellofIndex(): Could not find index.");
}

		
//PRIVATE FUNCTIONS
template<unsigned int dim>
void coupling::SequentialFilter<dim>::contribute() {	
	#ifdef DEBUG_SEQ_FILTER
	std::cout << "		SEQFILTER (" << _myRank << "): Sending cells and indices." << std::endl;
	#endif

	if(_processingRank == _myRank) {
		if(_firstIteration) {
			_filter->updateCellData(_inputCells_Global, _outputCells_Global, _cellIndices_Global);
			_firstIteration = false;
		}

		//Count cells that we update. This should be equal to _inputCells_Global.size().
		unsigned int cellsUpdated = 0;
		
		//Iteratate over all (contributing) ranks...
		for(int rank = 0; rank < _commSize; rank++) { //TODO: allow arbitrary comms: with ranks < _commSize that are not in _comm
			//Case: The contributing rank is the processing rank. In this case, we only need to copy cell data.
			if(rank == _myRank) {
				//Copy all cell data to global data structures.
				for(auto cell : _inputCells_Local) *_inputCells_Global[cellsUpdated] = *cell;
				for(auto index : _cellIndices_Local) _cellIndices_Local[cellsUpdated] = index;

				cellsUpdated++;
			}
			//Case: the contributing rank is not the processing rank. We need to communicate cell data using MPI.
			else {
				//Receive number of cells+indices that will be sent from that rank
				unsigned int numberOfCellsFromRank;
				MPI_Recv(&numberOfCellsFromRank, 1, MPI_UNSIGNED, rank, 0, _comm, MPI_STATUS_IGNORE);
				//TODO: debug output

				//Receive that many cells
				for(unsigned int c = 0; c < numberOfCellsFromRank; c++) {
					//receive cell
					MPI_Recv(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, rank, 0, _comm, MPI_STATUS_IGNORE);
					//receive corresponding index
					MPI_Recv(_indexbuf.data(), dim, MPI_UNSIGNED, rank, 0, _comm, MPI_STATUS_IGNORE);

					//Insert data received into global cell data structures
					bufferToMacroscopicCell(_cellbuf, _inputCells_Global[cellsUpdated]);
					bufferToCellIndex(_indexbuf, _cellIndices_Global[cellsUpdated]);
					
					cellsUpdated++;
				}
			}

			#ifdef DEBUG_SEQ_FILTER
			std::cout << "		SEQFILTER (" << _myRank << "): Received cells and indices from rank " << rank << std::endl;
			#endif
		}

		//TODO: Assert cellsUpdated == inputCells_Global.size()

		//This rank now processes...
	}
	else /* contributing rank */{
		
		//Communicate to processing rank how many cells+indices will be send
		unsigned int numberOfCellsFromThisRank = _filter->getInputCells().size();
		MPI_Send(&numberOfCellsFromThisRank, 1, MPI_UNSIGNED, _processingRank, 0, _comm);

		//Send that many cells (and indices)
		for(unsigned int c = 0; c < numberOfCellsFromThisRank; c++) {
			//fill buffers
			macroscopicCellToBuffer(_cellbuf, _filter->getInputCells()[c]);
			cellIndexToBuffer(_indexbuf, _filter->getCellIndices()[c]);

			//send cell
			MPI_Send(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, _processingRank, 0, _comm);
			//send corresponding index
			MPI_Send(_indexbuf.data(), 3, MPI_UNSIGNED, _processingRank, 0, _comm);
		}

		//The processing rank now processes...

		//Receive output data
		for(unsigned int c = 0; c < numberOfCellsFromThisRank; c++) {
			//receive cell
			MPI_Recv(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, _processingRank, 0, _comm, MPI_STATUS_IGNORE);
			//receive corresponding index
			MPI_Recv(_indexbuf.data(), 3, MPI_UNSIGNED, _processingRank, 0, _comm, MPI_STATUS_IGNORE);
			
			//find cell in filter's domain and apply
			tarch::la::Vector<dim, unsigned int> receivedIndex;
			bufferToCellIndex(_indexbuf, receivedIndex);
			bufferToMacroscopicCell(_cellbuf, _filter->getOutputCellOfIndex(receivedIndex));
		}
	}
}


template<unsigned int dim>
void coupling::SequentialFilter<dim>::process(bool sequential) {
	//Apply _filter
	(*_filter)();

	if(sequential) {
		//Now ready to distribute data back to the data's original ranks...
		for(unsigned int c = 0; c < _outputCells_Global.size(); c++) {
			//fill buffers with cell data
			macroscopicCellToBuffer(_cellbuf, _outputCells_Global[c]);
			cellIndexToBuffer(_indexbuf, _cellIndices_Global[c]);

			//get rank of cell
			int target_rank = _ic->getBaseIC()->getUniqueRankForMacroscopicCell(_cellIndices_Global[c]);
				
			//Case: cell belongs to this rank, no communication needed	
			if(target_rank == _processingRank)
				bufferToMacroscopicCell(_cellbuf, getLocalOutputCellOfIndex(_cellIndices_Global[c])); //TODO: this is the wrong target 
			//Case: other rank, we need to send cell and index
			else {
				//send cell
				MPI_Send(_cellbuf.data(), 4+3*dim, MPI_DOUBLE, target_rank, 0, _comm);
				//send corresponding index
				MPI_Send(_indexbuf.data(), 3, MPI_UNSIGNED, target_rank, 0, _comm);
			}
		}
	}
}


template<unsigned int dim>
void coupling::SequentialFilter<dim>::macroscopicCellToBuffer(std::vector<double>& buf, const coupling::datastructures::MacroscopicCell<dim>* cell){
	std::cout << "		SEQFILTER (" << _myRank << "): MCTB: Buffer size: " << buf.size() << std::endl;

	//Resize if buffer is too small to contain all cell data
	if(buf.capacity() < 4+3*dim) {
		buf.resize(4+3*dim); 
		std::cout << "		SEQFILTER (" << _myRank << "): MCTB: Cell buffer resized to: " << buf.size() << std::endl;
	}

	//copy cell data to buffer
	unsigned int i = 0;
	/*micro mass*/ 		buf[i] = cell->getMicroscopicMass(); i++; //std::cout << buf.back() << " ";
	/*micro momentum*/	for (unsigned d = 0; d < dim; d++) { buf[i] = cell->getMicroscopicMomentum()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*macro mass*/		buf[i] = cell->getMacroscopicMass(); i++; //std::cout << buf.back() << " ";
	/*macro momentum*/	for (unsigned d = 0; d < dim; d++) { buf[i] = cell->getMacroscopicMomentum()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*pot energy*/		buf[i] = cell->getPotentialEnergy(); i++; //std::cout << buf.back() << " ";
	/*velocity*/		for (unsigned d = 0; d < dim; d++) { buf[i] = cell->getCurrentVelocity()[d]; i++; /*std::cout << buf.back() << " ";*/ } 
	/*temperature*/		buf[i] = cell->getTemperature(); i++; //std::cout << buf.back() << " ";
	//std::cout << std::endl;
}


template<unsigned int dim>
void coupling::SequentialFilter<dim>::bufferToMacroscopicCell(const std::vector<double>& buf, coupling::datastructures::MacroscopicCell<dim>* cell) {
	std::cout << "		SEQFILTER (" << _myRank << "): BTMC: Buffer size: " << buf.size() << std::endl;
	if(buf.capacity() < 4+3*dim) throw std::runtime_error("Buffer too small for cell data!");

	tarch::la::Vector<dim, double> mvec_buf;
	unsigned int i = 0;
	//copy buffer data to cell
	/*micro mass*/ 		cell->setMicroscopicMass(buf[i]); i++;
	/*micro momentum*/	for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell->setMicroscopicMomentum(mvec_buf);
	/*macro mass*/		cell->setMacroscopicMass(buf[i]); i++;
	/*macro momentum*/	for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell->setMacroscopicMomentum(mvec_buf);
	/*pot energy*/		cell->setPotentialEnergy(buf[i]); i++;
	/*velocity*/		for(unsigned int d = 0; d < dim; d++) { mvec_buf[d] = buf[i]; i++; } cell->setCurrentVelocity(mvec_buf);
	/*temperature*/		cell->setTemperature(buf[i]); i++;
	//std::cout << cell << std::endl;
}


template<unsigned int dim>
void coupling::SequentialFilter<dim>::cellIndexToBuffer(std::vector<unsigned int>& buf, const tarch::la::Vector<dim, unsigned int>& index) {
	if(buf.capacity() < dim) buf.reserve(dim);
	for(unsigned int d = 0; d<dim; d++) buf[d] = index[d];
}


template<unsigned int dim>
void coupling::SequentialFilter<dim>::bufferToCellIndex(const std::vector<unsigned int>& buf, tarch::la::Vector<dim, unsigned int>& index) {
	for(unsigned int d = 0; d<dim; d++) index[d] = buf[d];
}
