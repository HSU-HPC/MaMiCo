// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamic::o


//Member functions of coupling::FilterSequence

template<unsigned int dim>
int coupling::FilterSequence<dim>::loadFiltersFromXML(tinyxml2::XMLElement* sequenceNode){
	if(!sequenceNode) return EXIT_FAILURE;
    tinyxml2::XMLElement* currFilterNode = sequenceNode->FirstChildElement();
	
	std::vector<coupling::datastructures::MacroscopicCell<dim>* > inputCellVector = _inputDomainCellVector;	
	std::vector<coupling::datastructures::MacroscopicCell<dim>* > outputCellVector = _domainCellVector2;	
	#ifdef DEBUG_FILTER_PIPELINE
	std::cout << PRINT_PREFIX() << "Initializing filter objects." << std::endl;
	#endif	
	bool firstIteration = true;
    while(currFilterNode){
		//"use" is not mandatory, default is false
		bool filteredValues[7] = { false };
		const char* fvStr = currFilterNode->Attribute("filtered-values");
		if(fvStr){
			if(strstr(fvStr, "all")) memset(filteredValues, true, sizeof(filteredValues));
			else{
				if(strstr(fvStr, "micro-mass")) filteredValues[0] = true;
				if(strstr(fvStr, "micro-momentum")) filteredValues[1] = true;
				if(strstr(fvStr, "macro-mass")) filteredValues[2] = true;
				if(strstr(fvStr, "macro-momentum")) filteredValues[3] = true;
				if(strstr(fvStr, "potential-energy")) filteredValues[4] = true;
				if(strstr(fvStr, "velocity")) filteredValues[5] = true;
				if(strstr(fvStr, "temperature")) filteredValues[6] = true;
			}
		}
        if(std::strcmp(currFilterNode->Value(), "write-to-file") == 0){
			bool overwrite = false;
			if(currFilterNode->Attribute("overwrite"))
				if(std::strcmp(currFilterNode->Attribute("overwrite"), "true") == 0)
					overwrite = true;
            _filters.push_back(new coupling::WriteToFile<dim>(inputCellVector, outputCellVector, _globalDomainCellIndices, filteredValues, _localDomainCellIndices, currFilterNode->Attribute("location"), overwrite));
        }
		else if(std::strcmp(currFilterNode->Value(), "gauss") == 0) {
			int d; //dimension of gauss filter
			if(currFilterNode->QueryIntAttribute("dim", &d)){
				std::cout << "ERROR: Gaussian Filter misses attribute dim in config file." << std::endl;
				exit(EXIT_FAILURE);
			}
			//"extrapolation" is not mandatory			
			const char* extrapolation;
			extrapolation = currFilterNode->Attribute("extrapolation");

            _filters.push_back(new coupling::Gauss<dim>(inputCellVector, outputCellVector, _localDomainCellIndices, filteredValues, (unsigned int) d, extrapolation));
		}
        else if(std::strcmp(currFilterNode->Value(), "POD") == 0) {
			//In earlier implementations, it used to be possible to override tws via function parameter. This feature was removed.
			//See: coupling::noisereduction::NoiseReductionConfiguration::interpreteConfiguration<dim>(..., int tws)
			int tws;
			if(currFilterNode->QueryIntAttribute("time-window-size", &tws)){
				std::cout << "ERROR: POD Filter misses attribute time-window-size in config file." << std::endl;
				exit(EXIT_FAILURE);
			}
			if(tws <= 2){
				std::cout << "ERROR: POD: time-window-size must be greater than two." << std::endl;
				exit(EXIT_FAILURE);
			}
			int kmax;
			if(currFilterNode->QueryIntAttribute("kmax", &kmax)){
				std::cout << "ERROR: POD Filter misses attribute kmax in config file." << std::endl;
				exit(EXIT_FAILURE);
			}
			if(kmax <= 0){
				std::cout << "ERROR: POD: kmax must be greater than zero.";
				exit(EXIT_FAILURE);
			}

            _filters.push_back(new coupling::POD<dim>(inputCellVector, outputCellVector, _localDomainCellIndices, filteredValues, tws, kmax));
        }
        else if(std::strcmp(currFilterNode->Value(), "NLM") == 0) {
            //TODO
            std::cout << "ERROR: Filter-Pipeline does not yet support NLM." << std::endl;
            exit(EXIT_FAILURE);
        }
        else {
			std::cout << "ERROR: Filter-Pipeline does not recognize filter called " << currFilterNode->Value() << std::endl;
            exit(EXIT_FAILURE);
        }

		if(firstIteration){
			inputCellVector = _domainCellVector1;
			firstIteration = false;
		}
		inputCellVector.swap(outputCellVector);
        currFilterNode = currFilterNode->NextSiblingElement();
        }
	#ifdef DEBUG_FILTER_PIPELINE
	std::cout << PRINT_PREFIX() << "Number of Filters: " << _filters.size() <<". Output vector will be ";
	if(_filters.size() % 2 == 1)  std::cout << "_cellVector1." << std::endl;
	else std::cout << "_cellVector2." << std::endl;
	#endif
	return 0;
}


template<unsigned int dim>
void coupling::FilterSequence<dim>::initCellVectors(){
	for(auto cell: _inputCellVector){
		_cellVector1.push_back(cell);
    	_cellVector2.push_back(cell);
	}
	#ifdef DEBUG_FILTER_PIPELINE
            std::cout << PRINT_PREFIX() << "Initialized (global) cell vector." << std::endl;
    #endif 
}

template<unsigned int dim>
void coupling::FilterSequence<dim>::initDomain(){
	#ifdef DEBUG_FILTER_PIPELINE
    std::cout << PRINT_PREFIX() << "Initializing domain. Input vector has " << _inputCellVector.size() << " cells. ";
    #endif
    //sanity check
    if(_inputCellVector.size() != _cellIndices.size()){
		std::cout << std::endl << "ERROR: Cell and index vector of sequence out of synch." << std::endl;
		exit(EXIT_FAILURE);
    }
    
    //sanity check
    for(unsigned int d = 0; d < dim; d++) if(_cellIndices.back()[d] < _domainEnd[d]){
		std::cout << std::endl << "ERROR: Sequence domain size larger than MD domain." << std::endl;
		exit(EXIT_FAILURE);
    }

    //sanity check
    for(unsigned int d = 0; d < dim; d++) if(_domainStart[d] > _domainEnd[d]){
		std::cout << std::endl << "ERROR: Filter domain start > domain end." << std::endl;
		exit(EXIT_FAILURE);
    }
    bool outOfBounds;
	for(unsigned int index = 0; index < _inputCellVector.size(); index++){
		outOfBounds = false;
		for(unsigned int d = 0; d < dim; d++) 
			//"index" does not reference the dim-dimensional indices stored in e.g. cellIndices but the cell vecto
			if(_cellIndices[index][d] < _domainStart[d] || _cellIndices[index][d] > _domainEnd[d]) outOfBounds = true;
		if(!outOfBounds){
			_inputDomainCellVector.push_back(_inputCellVector[index]);
			_domainCellVector1.push_back(_cellVector1[index]);
			_domainCellVector2.push_back(_cellVector2[index]);
			_globalDomainCellIndices.push_back(_cellIndices[index]);
			_localDomainCellIndices.push_back(_cellIndices[index]-_domainStart);
		}
	}
	
	#ifdef DEBUG_FILTER_PIPELINE
	std::cout << "Input domain vector has " << _inputDomainCellVector.size() << " cells." << std::endl;
	#endif
}

