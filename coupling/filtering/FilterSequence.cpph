// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico


//Member functions of coupling::FilterSequence

template<unsigned int dim>
int coupling::FilterSequence<dim>::loadFiltersFromXML(tinyxml2::XMLElement* sequenceNode){
	if(!sequenceNode) return EXIT_FAILURE;
    tinyxml2::XMLElement* currFilterNode = sequenceNode->FirstChildElement();
	
	tarch::la::Vector<dim, double> domainStart;
	tarch::la::Vector<dim, double> domainEnd;
	tarch::la::Vector<dim, unsigned int> domainStartCell;
	tarch::la::Vector<dim, unsigned int> domainEndCell;

    while(currFilterNode){
		#ifdef DEBUG_FILTER_PIPELINE
		std::cout << "FP: Initializing filter objects of sequence " << _name << ": ";
		#endif
		
		//TODO: implement tarch::configuration::readVectorOptional<...>(...), which returns nullptr if attribute doesnot exist
		tarch::configuration::ParseConfiguration::readVector<dim, double>(domainStart, currFilterNode, "domain-start");
		tarch::configuration::ParseConfiguration::readVector<dim, double>(domainEnd, currFilterNode, "domain-end");

		//TODO: check if not null
		for(unsigned int d = 0; d < dim; d++){
			domainStartCell[d] = (unsigned int) std::floor(domainStart[d] / _indexConversion->getMacroscopicCellSize()[d]);
			domainEndCell[d] = (unsigned int) std::ceil(domainEnd[d] / _indexConversion->getMacroscopicCellSize()[d]);
		}

        //Filter identifiers are hardcoded (for now at least):
        if(std::strcmp(currFilterNode->Value(), "write-to-file") == 0)
        {
			#ifdef DEBUG_FILTER_PIPELINE
			std::cout << "Write-To-File" << std::endl;
			#endif

            _filters.push_back(new coupling::WriteToFile<dim>(domainStartCell, domainEndCell, currFilterNode->Attribute("location")));
        }
        else if(std::strcmp(currFilterNode->Value(), "POD") == 0) {
       		//TODO
			std::cout << "ERROR: Filter-Pipeline does not yet support POD." << std::endl;
            //exit(EXIT_FAILURE);
        }
        else if(std::strcmp(currFilterNode->Value(), "NLM") == 0) {
            //TODO
            std::cout << "ERROR: Filter-Pipeline does not yet support NLM." << std::endl;
            //exit(EXIT_FAILURE);
        }
        else {
			std::cout << "ERROR: Filter-Pipeline does not recognize filter called " << currFilterNode->Value() << std::endl;
            //exit(EXIT_FAILURE);
        }

        currFilterNode = currFilterNode->NextSiblingElement();
        }
	return 0;
}

template<unsigned int dim>
void coupling::FilterSequence<dim>::fillSequenceData(
    const std::vector<coupling::datastructures::MacroscopicCell<dim>* > mdCellVector,
    const std::vector<tarch::la::Vector<dim, unsigned int>> mdCellIndices
){
    //Reset data vectors
    _macroscopicCells.clear();
    _cellIndices.clear();

    //If the input of a sequence is not defined, it's assumed to be the default input i.e. MD
    if(_input == nullptr){
        for(auto mdCell : mdCellVector){
            _macroscopicCells.push_back(mdCell);
        }
        for(auto mdCellIndex : mdCellIndices){
            _cellIndices.push_back(mdCellIndex);
        }

        #ifdef DEBUG_FILTER_PIPELINE
        std::cout << "FP: Supplied sequence named " << _name << " with cell data from MD." << std::endl;
        #endif
    }
    else{
        for(auto mdCell : _input->getMacroscopicCells()){
            _macroscopicCells.push_back(mdCell);
        }
        for(auto mdCellIndex : _input->getCellIndices()){
            _cellIndices.push_back(mdCellIndex);
        }
		
        #ifdef DEBUG_FILTER_PIPELINE
        std::cout << "FP: Supplied sequence named " << _name << " with cell data from " << _input->getName() << std::endl;
        #endif
    }

	for(auto filter : _filters)
		if(!(filter->isInitialized())) filter->initDomain(_macroscopicCells, _cellIndices);
}
