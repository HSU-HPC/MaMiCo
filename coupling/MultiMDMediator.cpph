// Copyright (C) 2016 Technische Universitaet Muenchen
// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico

template<class LinkedCell, unsigned int dim>
void 
coupling::MultiMDMediator<LinkedCell, dim>
::addMDSimulation(coupling::interface::MacroscopicSolverInterface<dim> * macroscopicSolverInterface) 
{
  unsigned int slot = reserveNextFreeSlot();

  _multiMDCellService.addMDSimulation(_instanceHandling, macroscopicSolverInterface, slot);

  unsigned int comm = slot / _multiMDService.getLocalNumberOfMDSimulations();
  unsigned int index = slot % _multiMDService.getLocalNumberOfMDSimulations();
  _listActiveMDSimulations[comm][index] = true;
}


template<class LinkedCell, unsigned int dim>
void
coupling::MultiMDMediator<LinkedCell, dim>
::addMDSimulation(coupling::interface::MacroscopicSolverInterface<dim> * macroscopicSolverInterface, const unsigned int & communicator)
{
  unsigned int counter = 0;
  for(auto & comm : _listActiveMDSimulations[communicator]) {
    counter += comm ? 1 : 0;
  }
  if(counter == _multiMDService.getLocalNumberOfMDSimulations()) { addMDSimulationBlock(); }

  for(unsigned int i=0;i<_listActiveMDSimulations[communicator].size();++i) {
    if(!_listActiveMDSimulations[communicator][i]) {
      unsigned int slot = communicator * _multiMDService.getLocalNumberOfMDSimulations() + i;
      _multiMDCellService.addMDSimulation(_instanceHandling, macroscopicSolverInterface, slot);
      _listActiveMDSimulations[communicator][i] = true;
      return;
    }
  }
}


template<class LinkedCell, unsigned int dim>
void
coupling::MultiMDMediator<LinkedCell, dim>
::addNMDSimulations(coupling::interface::MacroscopicSolverInterface<dim> * macroscopicSolverInterface, const unsigned int & n) {
 for(unsigned int i=0;i<n;++i) {
   addMDSimulation(macroscopicSolverInterface);
 }
}


template<class LinkedCell, unsigned int dim>
void
coupling::MultiMDMediator<LinkedCell, dim>
::addNMDSimulations(coupling::interface::MacroscopicSolverInterface<dim> * macroscopicSolverInterface, 
                      const unsigned int & n, const unsigned int & communicator) {
  for(unsigned int i=0;i<n;++i) {
    addMDSimulation(macroscopicSolverInterface, communicator);
  }
}


template<class LinkedCell, unsigned int dim>
void
coupling::MultiMDMediator<LinkedCell, dim>::rmMDSimulation() 
{
  if(_multiMDService.getLocalNumberOfMDSimulations() < 2) {
    // We need each communicator to have at least one active simulation running
    // otherwise all processes on this communicator would quickly run into shutdown
    // and thus would not be accessible to the simulation anymore.
    std::cout << "INFO MultiMDCellService::rmMDSimulation() : Cannot remove MD simulation, only one is left!" << std::endl;
    return;
  }

  unsigned int slot = getLastReservedSlot();
  unsigned int comm = slot / _multiMDService.getLocalNumberOfMDSimulations();
  unsigned int index = slot % _multiMDService.getLocalNumberOfMDSimulations();
  do {

    if(!_listActiveMDSimulations[comm][index]) {   
      //TODO find another simulation to be removed!!
      continue; 
    }

    _multiMDCellService.rmMDSimulation(_instanceHandling, slot);

    /** Check if there is a free block of simulations,
     * and, if so, remove it. Then reset _nextFreeBlock.
     */
    if(slot == _multiMDService.getTotalNumberOfMDSimulations()-1) {
      rmMDSimulationBlock();
      _nextFreeBlock = _multiMDService.getNumberLocalComms()-1;
    } 

    _listActiveMDSimulations[comm][index] = false;

  } while(_listActiveMDSimulations[comm][index] /*==true*/);
}


template<class LinkedCell, unsigned int dim>
void
coupling::MultiMDMediator<LinkedCell, dim>
::rmMDSimulation(const unsigned int & communicator, const unsigned int & localIndex) 
{
  if(_multiMDService.getLocalNumberOfMDSimulations() < 2) {
    // We need each communicator to have at least one active simulation running
    // otherwise all processes on this communicator would quickly run into shutdown
    // and thus would not be accessible to the simulation anymore.
    std::cout << "INFO MultiMDCellService::rmMDSimulation() : Cannot remove MD simulation, only one is left!" << std::endl;
    return;
  }

  unsigned int slot = communicator * _multiMDService.getLocalNumberOfMDSimulations() + localIndex;

  if (slot >= _multiMDService.getTotalNumberOfMDSimulations()) {
    std::cout << "WARNING MultiMDMediator::rmMDSimulation() : Invalid md slot!" << std::endl;
    return;
  }

  _multiMDCellService.rmMDSimulation(_instanceHandling, slot);

  _listActiveMDSimulations[communicator][localIndex] = false;
}


template<class LinkedCell, unsigned int dim>
void
coupling::MultiMDMediator<LinkedCell, dim>
::rmMDSimulation(const unsigned int & communicator)
{
  if(_multiMDService.getLocalNumberOfMDSimulations() < 2) {
    // We need each communicator to have at least one active simulation running
    // otherwise all processes on this communicator would quickly run into shutdown
    // and thus would not be accessible to the simulation anymore.
    std::cout << "INFO MultiMDCellService::rmMDSimulation() : Cannot remove MD simulation, only one is left!" << std::endl;
    return;
  }
  if(communicator >= _multiMDService.getNumberLocalComms()) {
    std::cout << "WARNING MultiMDMediator::rmMDSimulation() : Invalid communicator " << communicator << "!" << std::endl;
    return;
  }

  unsigned int slot = communicator * _multiMDService.getLocalNumberOfMDSimulations()
                    + _multiMDService.getLocalNumberOfMDSimulations()-1;

  _multiMDCellService.rmMDSimulation(_instanceHandling, slot);

  _listActiveMDSimulations[communicator][_multiMDCellService.getLocalNumberOfMDSimulations()-1] = false;
}


template<class LinkedCell, unsigned int dim>
unsigned int
coupling::MultiMDMediator<LinkedCell, dim>::reserveNextFreeSlot() 
{
    if(_nextFreeBlock == _multiMDService.getNumberLocalComms()-1) {
      /** If the next slot to be reserved would be on the last communicator,
       * this means that all communicators are full. We thus have to add
       * another sliced block of simulations slots
       */
      addMDSimulationBlock();
    }

    unsigned int thisFreeBlock = _nextFreeBlock;
    if(_nextFreeBlock == 0) {
      /** If a simulation slot has been reserved on communicator 0,
       * we start again at the last communicator.
       */
      _nextFreeBlock = _multiMDService.getNumberLocalComms()-1;
    } else {
      _nextFreeBlock -= 1;
    }
    
    return thisFreeBlock * _multiMDService.getLocalNumberOfMDSimulations() 
        + _multiMDService.getLocalNumberOfMDSimulations() - 1;
}


template<class LinkedCell, unsigned int dim>
unsigned int
coupling::MultiMDMediator<LinkedCell,dim>::getLastReservedSlot() 
{
  if(_nextFreeBlock == _multiMDService.getNumberLocalComms()-1) {

    _nextFreeBlock = 0;
    return _multiMDService.getLocalNumberOfMDSimulations()-1;
  }
  unsigned int thisFreeBlock = _nextFreeBlock;
  _nextFreeBlock += 1;
  return (thisFreeBlock+1) * _multiMDService.getLocalNumberOfMDSimulations() + 
        + _multiMDService.getLocalNumberOfMDSimulations()-1;
}


template<class LinkedCell, unsigned int dim>
void
coupling::MultiMDMediator<LinkedCell,dim>::addMDSimulationBlock() 
{
  _multiMDCellService.addSimulationBlock();

  _multiMDService.addMDSimulationBlock();

  for(auto & group : _listActiveMDSimulations) {
    group.push_back(false);
  }
}

template<class LinkedCell, unsigned int dim>
void
coupling::MultiMDMediator<LinkedCell,dim>::rmMDSimulationBlock() 
{
  _multiMDCellService.removeSimulationBlock();

  for(auto & group : _listActiveMDSimulations) {
    group.pop_back();
  }

  _multiMDService.removeMDSimulationBlock();
}