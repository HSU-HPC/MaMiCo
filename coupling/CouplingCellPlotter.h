// Copyright (C) 2015 Technische Universitaet Muenchen
// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico
#ifndef _MOLECULARDYNAMICS_COUPLING_COUPLINGCELLPLOTTER_H_
#define _MOLECULARDYNAMICS_COUPLING_COUPLINGCELLPLOTTER_H_

#include "coupling/IndexConversion.h"
#include "coupling/KineticEnergyController.h"
#include "coupling/cell-mappings/ComputeMassMapping.h"
#include "coupling/cell-mappings/ComputeMomentumMapping.h"
#include "coupling/cell-mappings/VTKMoleculePlotter.h"
#include "coupling/datastructures/CouplingCellsWithLinkedCells.h"
#include "coupling/interface/MDSolverInterface.h"
#include "tarch/la/Vector.h"
#include <fstream>
#include <sstream>

namespace coupling {
template <class LinkedCell, unsigned int dim> class CouplingCellPlotter;
}

/** @brief plots the coupling cell data.
 *  @author Philipp Neumann
 *  @tparam LinkedCell the LinkedCell class is given by the implementation of
 * linked cells in the molecular dynamics simulation
 *  @tparam dim  refers to the spacial dimension of the simulation, can be 1, 2,
 * or 3*/
template <class LinkedCell, unsigned int dim> class coupling::CouplingCellPlotter {
public:
  /** @brief a simple constructor
   *  @param ID the id of the md simulation
   *  @param filename name for the file
   *  @param rank mpi rank of the current process
   *  @param t number of time step to plot
   *  @param indexConversion indexConversion instance of the current simulation
   *  @param cells coupling cells to plot
   *  @param mdSolverInterface interface of the md solver */
  CouplingCellPlotter(unsigned int ID, std::string filename, unsigned int rank, unsigned int t, const coupling::IndexConversion<dim>& indexConversion,
                      coupling::datastructures::CouplingCellsWithLinkedCells<LinkedCell, dim>& cells,
                      coupling::interface::MDSolverInterface<LinkedCell, dim>* const mdSolverInterface) {
    plotMoleculeFile(ID, filename, rank, t, cells, mdSolverInterface);
    plotCouplingCellFile(ID, filename, rank, t, indexConversion, cells, mdSolverInterface);
  }

  /** @brief a simple destructor*/
  ~CouplingCellPlotter() {}

private:
  /** the file will contain the velocity, position, and potentials of the
   * molecules
   *  @brief writes molecule information to VTK file.
   *  @param ID the id of the md simulation
   *  @param filename name for the file
   *  @param rank mpi rank of the current process
   *  @param t number of time step to plot
   *  @param cells coupling cells to plot
   *  @param mdSolverInterface interface of the md solver */
  void plotMoleculeFile(unsigned int ID, std::string filename, unsigned int rank, unsigned int t,
                        coupling::datastructures::CouplingCellsWithLinkedCells<LinkedCell, dim>& cells,
                        coupling::interface::MDSolverInterface<LinkedCell, dim>* const mdSolverInterface) {
    // open files
    std::ofstream moleculeFile;
    // store positions and velocities of molecules
    std::stringstream moleculeVelocities;
    std::stringstream moleculePositions;
    std::stringstream moleculePotentials;
    // zeros appended in vtk file
    std::string appendFloatZeros("");
    switch (dim) {
    case 1:
      appendFloatZeros = " 0.0 0.0";
      break;
    case 2:
      appendFloatZeros = " 0.0";
      break;
    case 3:
      appendFloatZeros = "";
      break;
    default:
      break;
    }
    Writer4Molecules writer(moleculeVelocities, moleculePositions, moleculePotentials, appendFloatZeros, mdSolverInterface);
    cells.applyToLocalNonGhostCouplingCellsWithLinkedCells(writer);
    // open file and write info
    open(ID, filename, "Molecules", rank, t, moleculeFile);
    moleculeFile << "# vtk DataFile Version 2.0" << std::endl;
    moleculeFile << "Generated by MaMiCo (Philipp Neumann)" << std::endl;
    moleculeFile << "ASCII" << std::endl;
    moleculeFile << "DATASET UNSTRUCTURED_GRID" << std::endl;
    moleculeFile << "POINTS " << writer.getMoleculeCounter() << " float" << std::endl;
    moleculeFile << moleculePositions.str() << std::endl << std::endl;
    moleculeFile << "POINT_DATA " << writer.getMoleculeCounter() << std::endl;
    moleculeFile << "VECTORS velocity float" << std::endl;
    moleculeFile << moleculeVelocities.str() << std::endl;
    moleculeFile << "SCALARS potentialEnergy float 1" << std::endl;
    moleculeFile << "LOOKUP_TABLE DEFAULT" << std::endl;
    moleculeFile << moleculePotentials.str() << std::endl;
    moleculePositions.clear();
    moleculePositions.str("");
    moleculeVelocities.clear();
    moleculeVelocities.str("");
    moleculePotentials.clear();
    moleculePotentials.str("");
    moleculeFile.close();
  }

  /** @brief writes molecule information + coupling cell information to VTK
   * file.
   *  @param ID the id of the md simulation
   *  @param filename name for the file
   *  @param rank mpi rank of the current process
   *  @param t number of time step to plot
   *  @param indexConversion indexConversion instance of the current simulation
   *  @param cells coupling cells to plot
   *  @param mdSolverInterface interface of the md solver */
  void plotCouplingCellFile(unsigned int ID, std::string filename, unsigned int rank, unsigned int t, const coupling::IndexConversion<dim>& indexConversion,
                            coupling::datastructures::CouplingCellsWithLinkedCells<LinkedCell, dim>& cells,
                            coupling::interface::MDSolverInterface<LinkedCell, dim>* const mdSolverInterface) {
    // stringstreams for all cell properties of interest
    std::stringstream microscopicMasses;
    microscopicMasses << "SCALARS microscopicMassBuffer float 1" << std::endl;
    microscopicMasses << "LOOKUP_TABLE DEFAULT" << std::endl;
    std::stringstream macroscopicMasses;
    macroscopicMasses << "SCALARS macroscopicMassBuffer float 1" << std::endl;
    macroscopicMasses << "LOOKUP_TABLE DEFAULT" << std::endl;
    std::stringstream microscopicMomenta;
    microscopicMomenta << "VECTORS microscopicMomentumBuffer float" << std::endl;
    std::stringstream macroscopicMomenta;
    macroscopicMomenta << "VECTORS macroscopicMomentumBuffer float" << std::endl;
    std::stringstream meanVelocities;
    meanVelocities << "VECTORS meanVelocity float" << std::endl;
    std::stringstream masses;
    masses << "SCALARS mass float 1" << std::endl;
    masses << "LOOKUP_TABLE DEFAULT" << std::endl;
    std::stringstream energies;
    energies << "SCALARS meanPotentialEnergyBuffer float 1" << std::endl;
    energies << "LOOKUP_TABLE DEFAULT" << std::endl;
    std::stringstream temperatures;
    temperatures << "SCALARS temperature float 1" << std::endl;
    temperatures << "LOOKUP_TABLE DEFAULT" << std::endl;
    // ofstream for file
    std::ofstream ofCell;
    // zeros appended in vtk file
    std::string appendFloatZeros("");
    switch (dim) {
    case 1:
      appendFloatZeros = " 0.0 0.0";
      break;
    case 2:
      appendFloatZeros = " 0.0";
      break;
    case 3:
      appendFloatZeros = "";
      break;
    default:
      break;
    }
    // number of points
    const tarch::la::Vector<3, unsigned int> numberCells =
        coupling::initRange<dim>(indexConversion.getLocalNumberCouplingCells() + tarch::la::Vector<dim, unsigned int>(2));
    tarch::la::Vector<3, double> original(0.0);
    for (unsigned int d = 0; d < dim; d++) {
      original[d] = indexConversion.getGlobalMDDomainOffset()[d] - 0.5 * indexConversion.getCouplingCellSize()[d] +
                    indexConversion.getAverageLocalNumberCouplingCells()[d] * indexConversion.getThisProcess()[d] * indexConversion.getCouplingCellSize()[d];
    }
    // open file
    open(ID, filename, "CouplingCells", rank, t, ofCell);
    Writer4Cells writer(microscopicMasses, macroscopicMasses, microscopicMomenta, macroscopicMomenta, meanVelocities, masses, energies, temperatures,
                        appendFloatZeros, indexConversion, mdSolverInterface);
    cells.applyToAllLocalCouplingCellsWithLinkedCells(writer);
    ofCell << "# vtk DataFile Version 2.0" << std::endl;
    ofCell << "generated by MaMiCo (Philipp Neumann)" << std::endl;
    ofCell << "ASCII" << std::endl << std::endl;
    ofCell << "DATASET STRUCTURED_POINTS" << std::endl;
    ofCell << "DIMENSIONS " << numberCells[0] << " " << numberCells[1] << " " << numberCells[2] << std::endl;
    ofCell << "ORIGIN ";
    for (unsigned int d = 0; d < 3; d++) {
      ofCell << original[d] << " ";
    }
    ofCell << std::endl;
    ofCell << "SPACING ";
    for (unsigned int d = 0; d < dim; d++) {
      ofCell << indexConversion.getCouplingCellSize()[d] << " ";
    }
    for (unsigned int d = dim; d < 3; d++) {
      ofCell << "1.0 ";
    }
    ofCell << std::endl;
    ofCell << "POINT_DATA " << numberCells[0] * numberCells[1] * numberCells[2] << std::endl << std::endl;
    ofCell << microscopicMasses.str() << std::endl << std::endl;
    microscopicMasses.clear();
    microscopicMasses.str("");
    ofCell << macroscopicMasses.str() << std::endl << std::endl;
    macroscopicMasses.clear();
    macroscopicMasses.str("");
    ofCell << masses.str() << std::endl << std::endl;
    masses.clear();
    masses.str("");
    ofCell << energies.str() << std::endl << std::endl;
    energies.clear();
    energies.str("");
    ofCell << temperatures.str() << std::endl << std::endl;
    temperatures.clear();
    temperatures.str("");
    ofCell << microscopicMomenta.str() << std::endl << std::endl;
    microscopicMomenta.clear();
    microscopicMomenta.str("");
    ofCell << macroscopicMomenta.str() << std::endl << std::endl;
    macroscopicMomenta.clear();
    macroscopicMomenta.str("");
    ofCell << meanVelocities.str() << std::endl << std::endl;
    meanVelocities.clear();
    meanVelocities.str("");
    // close file
    ofCell.close();
  }

  /** @brief opens a file
   *  @param ID the id of the md simulation
   *  @param filename name for the file
   *  @param fileType type of the file (e.g. vtk)
   *  @param rank mpi rank of the current process
   *  @param t number of time step to plot
   *  @param of this is the stream, where it will be written to */
  void open(unsigned int ID, std::string filename, std::string fileType, unsigned int rank, unsigned int t, std::ofstream& of) {
    std::stringstream ss;
    ss << filename << "_" << fileType << "_" << ID << "_" << rank << "_" << t << ".vtk";
    of.open(ss.str().c_str());
    if (!of.is_open()) {
      std::cout << "ERROR coupling::CouplingCellPlotter: Could not open file " << ss.str() << "!" << std::endl;
      exit(EXIT_FAILURE);
    }
  }

  /** @brief class for writing coupling cell data to stringstreams.
   *  @author Philipp Neumann*/
  class Writer4Cells {
  public:
    /** @brief a simple constructor
     *  @param microscopicMasses stream for the microscopic masses
     *  @param macroscopicMasses stream for the macroscopic masses
     *  @param microscopicMomenta stream for the microscopic momenta
     *  @param macroscopicMomenta stream for the macroscopic momenta
     *  @param meanVelocities stream for the mean velocities
     *  @param masses stream for the masses
     *  @param energies stream for the energies
     *  @param temperatures stream for the temperatures
     *  @param appendFloatZeros string containing '0' to add in the case of 1d
     * or 2d
     *  @param indexConversion instance of the indexConversion class
     *  @param mdSolverInterface interface of the md solver */
    Writer4Cells(std::stringstream& microscopicMasses, std::stringstream& macroscopicMasses, std::stringstream& microscopicMomenta,
                 std::stringstream& macroscopicMomenta, std::stringstream& meanVelocities, std::stringstream& masses, std::stringstream& energies,
                 std::stringstream& temperatures, const std::string& appendFloatZeros, const coupling::IndexConversion<dim>& indexConversion,
                 coupling::interface::MDSolverInterface<LinkedCell, dim>* const mdSolverInterface)
        : _microscopicMasses(microscopicMasses), _macroscopicMasses(macroscopicMasses), _microscopicMomenta(microscopicMomenta),
          _macroscopicMomenta(macroscopicMomenta), _meanVelocities(meanVelocities), _masses(masses), _energies(energies), _temperatures(temperatures),
          _appendFloatZeros(appendFloatZeros), _computeMassMapping(mdSolverInterface), _computeMomentumMapping(mdSolverInterface),
          _kineticEnergyController(mdSolverInterface), _indexConversion(indexConversion) {}

    /** @brief a simple destructor*/
    ~Writer4Cells() {}

    /** @brief does everything which is neccessary before the application of the
     * writer to the cells */
    void beginCellIteration() {}

    /** @brief does everything which is neccessary after the application of the
     * writer to the cells */
    void endCellIteration() {}

    /** @brief writes the data from the cell to the stringstreams
     *  @param cell coupling cell
     *  @param index linearised index of the coupling cell*/
    void apply(coupling::datastructures::CouplingCellWithLinkedCells<LinkedCell, dim>& cell, const unsigned int& index) {
      // compute local quantities from molecules, if this is an inner cell
      const tarch::la::Vector<dim, unsigned int> end = _indexConversion.getLocalNumberCouplingCells() + tarch::la::Vector<dim, unsigned int>(1);
      const tarch::la::Vector<dim, unsigned int> localIndex = _indexConversion.getLocalVectorCellIndex(index);
      bool isInnerCell = true;
      for (unsigned int d = 0; d < dim; d++) {
        isInnerCell = isInnerCell && (localIndex[d] > 0) && (localIndex[d] < end[d]);
      }
      double mass = 0.0;
      tarch::la::Vector<dim, double> meanVelocity(0.0);
      double temperature = 0.0;

      if (isInnerCell) {
        cell.iterateConstCells(_computeMassMapping);
        mass = _computeMassMapping.getMass();
        cell.iterateConstCells(_computeMomentumMapping);
        meanVelocity = _computeMomentumMapping.getMeanVelocity();
        temperature = _kineticEnergyController.computeTemperature(cell);
      }

      // write data to streams
      _microscopicMasses << cell.getMicroscopicMass() << std::endl;
      _macroscopicMasses << cell.getMacroscopicMass() << std::endl;
      _masses << mass << std::endl;
      _temperatures << temperature << std::endl;
      _energies << cell.getPotentialEnergy() << std::endl;
      for (unsigned int d = 0; d < dim; d++) {
        _microscopicMomenta << cell.getMicroscopicMomentum()[d] << " ";
        _macroscopicMomenta << cell.getMacroscopicMomentum()[d] << " ";
        _meanVelocities << meanVelocity[d] << " ";
      }
      _microscopicMomenta << _appendFloatZeros << std::endl;
      _macroscopicMomenta << _appendFloatZeros << std::endl;
      _meanVelocities << _appendFloatZeros << std::endl;
    }

  private:
    /** stream containing the microscopic mass of the cells (buffer to transfer
     * mass from macro to md)*/
    std::stringstream& _microscopicMasses;
    /** stream containing the macroscopic mass of the cells (buffer to transfer
     * mass from md to macro)*/
    std::stringstream& _macroscopicMasses;
    /** stream containing the microscopic momenta of the cells (buffer to
     * transfer momenta from macro to md)*/
    std::stringstream& _microscopicMomenta;
    /** stream containing the macroscopic momenta of the cells (buffer to
     * transfer momenta from md to macro )*/
    std::stringstream& _macroscopicMomenta;
    /** stream containing the mean velocity of the cells*/
    std::stringstream& _meanVelocities;
    /** stream containing the total mass in the cells*/
    std::stringstream& _masses;
    /** stream containing the total energy in the cells*/
    std::stringstream& _energies;
    /** stream containing the mean temperature in the cells*/
    std::stringstream& _temperatures;
    /** string containing '0' to add in the case of 1d or 2d */
    const std::string _appendFloatZeros;
    /** instance of the computeMassMapping*/
    coupling::cellmappings::ComputeMassMapping<LinkedCell, dim> _computeMassMapping;
    /** instance of the computeMomentumMapping*/
    coupling::cellmappings::ComputeMomentumMapping<LinkedCell, dim> _computeMomentumMapping;
    /** instance of the KineticEnergyController*/
    coupling::KineticEnergyController<LinkedCell, dim> _kineticEnergyController;
    /** instance of the indexConversion*/
    const coupling::IndexConversion<dim>& _indexConversion;
  };

  /** We make use of the traversal callback pattern of CouplingCells.
   *  @brief class for writing molecule data to stringstreams.
   *  @author Philipp Neumann */
  class Writer4Molecules {
  public:
    /** @brief a simple constructor
     *  @param moleculeVelocities stream for the molecule velocities
     *  @param moleculePositions stream for the molecule positions
     *  @param moleculePotentials stream for the molecule potentials
     *  @param appendFloatZeros string containing '0' to add in the case of 1d
     * or 2d
     *  @param mdSolverInterface interface of the md solver */
    Writer4Molecules(std::stringstream& moleculeVelocities, std::stringstream& moleculePositions, std::stringstream& moleculePotentials,
                     const std::string& appendFloatZeros, coupling::interface::MDSolverInterface<LinkedCell, dim>* const mdSolverInterface)
        : _moleculeVelocities(moleculeVelocities), _moleculePositions(moleculePositions), _moleculePotentials(moleculePotentials),
          _appendFloatZeros(appendFloatZeros), _mdSolverInterface(mdSolverInterface), _moleculeCounter(0) {}

    /** @brief does everything which is neccessary before the application of the
     * writer to the cells */
    void beginCellIteration() {}

    /** @brief does everything which is neccessary after the application of the
     * writer to the cells */
    void endCellIteration() {}

    /** @brief aplication of the vtkMoleculePlotter to the coupling cells*/
    void apply(coupling::datastructures::CouplingCellWithLinkedCells<LinkedCell, dim>& cell, const unsigned int& index) {
      coupling::cellmappings::VTKMoleculePlotter<LinkedCell, dim> vtkMoleculePlotter(_moleculeVelocities, _moleculePositions, _moleculePotentials,
                                                                                     _appendFloatZeros, _mdSolverInterface);
      cell.iterateConstCells(vtkMoleculePlotter);
      _moleculeCounter += vtkMoleculePlotter.getParticleCounter();
    }

    /** @brief returns the number of molecules
     *  @returns the number of molecules plotted */
    unsigned int getMoleculeCounter() const { return _moleculeCounter; }

  private:
    /** stringstream for the velocities of the molecules*/
    std::stringstream& _moleculeVelocities;
    /** stringstream for the positions of the molecules*/
    std::stringstream& _moleculePositions;
    /** stringstream for the potentials of the molecules*/
    std::stringstream& _moleculePotentials;
    /** string containing '0' to add in the case of 1d or 2d */
    const std::string _appendFloatZeros;
    /** interface to the md solver*/
    coupling::interface::MDSolverInterface<LinkedCell, dim>* const _mdSolverInterface;
    /** counter for the molecules that have been plotted*/
    unsigned int _moleculeCounter;
  };
};
#endif // _MOLECULARDYNAMICS_COUPLING_COUPLINGCELLPLOTTER_H_
