// Copyright (C) 2015 Technische Universitaet Muenchen
// This file is part of the Mamico project. For conditions of distribution
// and use, please see the copyright notice in Mamico's main folder, or at
// www5.in.tum.de/mamico

template <class LinkedCell, unsigned int dim>
coupling::datastructures::MacroscopicCells<LinkedCell, dim>::MacroscopicCells(tarch::la::Vector<dim, unsigned int> numberLinkedCellsPerMacroscopicCell,
                                                                              const coupling::IndexConversion<dim>& indexConversion,
                                                                              coupling::interface::MDSolverInterface<LinkedCell, dim>* mdSolverInterface)
    : _macroscopicCellsWithLinkedCells(initMacroscopicCellsWithLinkedCells(numberLinkedCellsPerMacroscopicCell, indexConversion, mdSolverInterface)),
      _macroscopicCells(initMacroscopicCells(indexConversion)), _indexConversion(indexConversion) {
#if (COUPLING_MD_DEBUG == COUPLING_MD_YES)
  std::cout << "Macroscopic cells initialised..." << std::endl;
#endif
}

template <class LinkedCell, unsigned int dim> coupling::datastructures::MacroscopicCells<LinkedCell, dim>::~MacroscopicCells() {
  // delete pointers and clear vector
  const unsigned int size = (unsigned int)_macroscopicCells.size();
  for (unsigned int i = 0; i < size; i++) {
    _macroscopicCells[i] = NULL;
  }
  _macroscopicCells.clear();
  if (_macroscopicCellsWithLinkedCells != NULL) {
    // call all destructors explicitly
    for (unsigned int i = 0; i < size; i++) {
      coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell, dim>* cell = &_macroscopicCellsWithLinkedCells[i];
      cell->~MacroscopicCellWithLinkedCells();
    }
    // free memory
    free(_macroscopicCellsWithLinkedCells);
    _macroscopicCellsWithLinkedCells = NULL;
  }
}

template <class LinkedCell, unsigned int dim>
coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell, dim>*
coupling::datastructures::MacroscopicCells<LinkedCell, dim>::getMacroscopicCellsWithLinkedCells() {
  return _macroscopicCellsWithLinkedCells;
}

template <class LinkedCell, unsigned int dim>
const std::vector<coupling::datastructures::MacroscopicCell<dim>*>& coupling::datastructures::MacroscopicCells<LinkedCell, dim>::getMacroscopicCells() const {
  return _macroscopicCells;
}

template <class LinkedCell, unsigned int dim>
coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell, dim>*
coupling::datastructures::MacroscopicCells<LinkedCell, dim>::initMacroscopicCellsWithLinkedCells(
    tarch::la::Vector<dim, unsigned int> numberLinkedCellsPerMacroscopicCell, const coupling::IndexConversion<dim>& indexConversion,
    coupling::interface::MDSolverInterface<LinkedCell, dim>* mdSolverInterface) const {
  // determine local number of macroscopic cells
  unsigned int numberMacroscopicCells = 1;
  for (unsigned int d = 0; d < dim; d++) {
    numberMacroscopicCells = numberMacroscopicCells * (indexConversion.getLocalNumberMacroscopicCells()[d] + 2);
  }

  // determine start and end coordinates for loop over inner macroscopic cells
  const tarch::la::Vector<3, unsigned int> start(1);
  const tarch::la::Vector<3, unsigned int> end = start + coupling::initRange<dim>(indexConversion.getLocalNumberMacroscopicCells());
  tarch::la::Vector<3, unsigned int> macroLoop(0);

  // determine end coordinate for inner loop over linked cells (contained in each macroscopic cell)
  const tarch::la::Vector<3, unsigned int> endInnerLoop = coupling::initRange<dim>(numberLinkedCellsPerMacroscopicCell);

  // allocate macroscopic cells
  coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell, dim>* cells =
      (coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell, dim>*)malloc(
          sizeof(coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell, dim>) * numberMacroscopicCells);
  if (cells == NULL) {
    std::cout << "ERROR coupling::datastructures::MacroscopicCells::initMacroscopicCells(): cells==NULL!" << std::endl;
    exit(EXIT_FAILURE);
  }

  // call constructor on each macroscopic cell
  for (unsigned int i = 0; i < numberMacroscopicCells; i++) {
    // initialise macroscopic cell
    coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell, dim>* newCell =
        new (&cells[i]) coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell, dim>(numberLinkedCellsPerMacroscopicCell);
    if (newCell == NULL) {
      std::cout << "ERROR coupling::datastructures::MacroscopicCells::initMacroscopicCellsWithLinkedCells(): newCell==NULL" << std::endl;
      exit(EXIT_FAILURE);
    }
  }

  // loop over inner macroscopic cells and set pointers to linked cells
  for (macroLoop[2] = start[2]; macroLoop[2] < end[2]; macroLoop[2]++) {
    for (macroLoop[1] = start[1]; macroLoop[1] < end[1]; macroLoop[1]++) {
      for (macroLoop[0] = start[0]; macroLoop[0] < end[0]; macroLoop[0]++) {

        // determine macroscopic cell index
        tarch::la::Vector<dim, unsigned int> macroscopicCellIndex = coupling::initDimVector<dim>(macroLoop);
        const unsigned int linearisedIndex = indexConversion.getLocalCellIndex(macroscopicCellIndex);

        // loop over linked cells inside this macroscopic cell
        unsigned int linkedCounter = 0;
        tarch::la::Vector<3, unsigned int> linkedLoop(0);
        for (linkedLoop[2] = 0; linkedLoop[2] < endInnerLoop[2]; linkedLoop[2]++) {
          for (linkedLoop[1] = 0; linkedLoop[1] < endInnerLoop[1]; linkedLoop[1]++) {
            for (linkedLoop[0] = 0; linkedLoop[0] < endInnerLoop[0]; linkedLoop[0]++) {
              tarch::la::Vector<dim, unsigned int> linkedCellIndex = coupling::initDimVector<dim>(linkedLoop);
              cells[linearisedIndex].addLinkedCell(
                  mdSolverInterface->getLinkedCell(macroscopicCellIndex, linkedCellIndex, numberLinkedCellsPerMacroscopicCell, indexConversion), linkedCounter);

              linkedCounter++;
            }
          }
        } // loop (linked cells in macroscopic cell)
      }
    }
  } // loop (inner macroscopic cells)

  return cells;
}

template <class LinkedCell, unsigned int dim>
template <class A>
void coupling::datastructures::MacroscopicCells<LinkedCell, dim>::applyToLocalNonGhostMacroscopicCellsWithLinkedCells(A& a) {
  const tarch::la::Vector<3, unsigned int> start(1);
  const tarch::la::Vector<3, unsigned int> end = start + coupling::initRange<dim>(_indexConversion.getLocalNumberMacroscopicCells());
  tarch::la::Vector<3, unsigned int> loop(0);

  a.beginCellIteration();
  for (loop[2] = start[2]; loop[2] < end[2]; loop[2]++) {
    for (loop[1] = start[1]; loop[1] < end[1]; loop[1]++) {
      for (loop[0] = start[0]; loop[0] < end[0]; loop[0]++) {
        const tarch::la::Vector<dim, unsigned int> vectorIndex = coupling::initDimVector<dim>(loop);
        const unsigned int linearIndex = _indexConversion.getLocalCellIndex(vectorIndex);
        a.apply(_macroscopicCellsWithLinkedCells[linearIndex], linearIndex);
      }
    }
  }
  a.endCellIteration();
}

template <class LinkedCell, unsigned int dim>
template <class A>
void coupling::datastructures::MacroscopicCells<LinkedCell, dim>::applyToLocalGhostMacroscopicCellsWithLinkedCells(A& a) {
  const tarch::la::Vector<dim, unsigned int> totalNumberCells = _indexConversion.getLocalNumberMacroscopicCells() + tarch::la::Vector<dim, unsigned int>(2);
  tarch::la::Vector<dim, unsigned int> loop(0);
  unsigned int index = 0;

  a.beginCellIteration();
  switch (dim) {
  case 1:
    // left boundary
    loop[0] = 0;
    index = _indexConversion.getLocalCellIndex(loop);
    a.apply(_macroscopicCellsWithLinkedCells[index], index);
    // right boundary
    loop[0] = totalNumberCells[0] - 1;
    index = _indexConversion.getLocalCellIndex(loop);
    a.apply(_macroscopicCellsWithLinkedCells[index], index);
    break;
  case 2:
    // lower and upper boundary
    for (loop[0] = 0; loop[0] < totalNumberCells[0]; loop[0]++) {
      loop[1] = 0;
      index = _indexConversion.getLocalCellIndex(loop);
      a.apply(_macroscopicCellsWithLinkedCells[index], index);
      loop[1] = totalNumberCells[1] - 1;
      index = _indexConversion.getLocalCellIndex(loop);
      a.apply(_macroscopicCellsWithLinkedCells[index], index);
    }
    // left and right boundary
    for (loop[1] = 1; loop[1] < totalNumberCells[1] - 1; loop[1]++) {
      loop[0] = 0;
      index = _indexConversion.getLocalCellIndex(loop);
      a.apply(_macroscopicCellsWithLinkedCells[index], index);
      loop[0] = totalNumberCells[0] - 1;
      index = _indexConversion.getLocalCellIndex(loop);
      a.apply(_macroscopicCellsWithLinkedCells[index], index);
    }
    break;
  case 3:
    // top/ bottom boundary
    for (loop[1] = 0; loop[1] < totalNumberCells[1]; loop[1]++) {
      for (loop[0] = 0; loop[0] < totalNumberCells[0]; loop[0]++) {
        loop[2] = 0;
        index = _indexConversion.getLocalCellIndex(loop);
        a.apply(_macroscopicCellsWithLinkedCells[index], index);
        loop[2] = totalNumberCells[2] - 1;
        index = _indexConversion.getLocalCellIndex(loop);
        a.apply(_macroscopicCellsWithLinkedCells[index], index);
      }
    }
    // front/ back boundary
    for (loop[2] = 1; loop[2] < totalNumberCells[2] - 1; loop[2]++) {
      for (loop[0] = 0; loop[0] < totalNumberCells[0]; loop[0]++) {
        loop[1] = 0;
        index = _indexConversion.getLocalCellIndex(loop);
        a.apply(_macroscopicCellsWithLinkedCells[index], index);
        loop[1] = totalNumberCells[1] - 1;
        index = _indexConversion.getLocalCellIndex(loop);
        a.apply(_macroscopicCellsWithLinkedCells[index], index);
      }
    }
    // left/ right boundary
    for (loop[2] = 1; loop[2] < totalNumberCells[2] - 1; loop[2]++) {
      for (loop[1] = 1; loop[1] < totalNumberCells[1] - 1; loop[1]++) {
        loop[0] = 0;
        index = _indexConversion.getLocalCellIndex(loop);
        a.apply(_macroscopicCellsWithLinkedCells[index], index);
        loop[0] = totalNumberCells[0] - 1;
        index = _indexConversion.getLocalCellIndex(loop);
        a.apply(_macroscopicCellsWithLinkedCells[index], index);
      }
    }
    break;
  default:
    std::cout << "ERROR coupling::datastructures::MacroscopicCells::applyToLocalGhostMacroscopicCellsWithLinkedCells(): Only 1D/2D/3D supported!" << std::endl;
    exit(EXIT_FAILURE);
  }
  a.endCellIteration();
}

template <class LinkedCell, unsigned int dim>
template <class A>
void coupling::datastructures::MacroscopicCells<LinkedCell, dim>::applyToAllLocalMacroscopicCellsWithLinkedCells(A& a) {
  const tarch::la::Vector<3, unsigned int> end =
      coupling::initRange<dim>(_indexConversion.getLocalNumberMacroscopicCells() + tarch::la::Vector<dim, unsigned int>(2));
  tarch::la::Vector<3, unsigned int> loop(0);

  // we assume a lexicographic ordering of the cells. We can then just increment the linearIndex counter in each cellwise operation.
  a.beginCellIteration();
  unsigned int linearIndex = 0;
  for (loop[2] = 0; loop[2] < end[2]; loop[2]++) {
    for (loop[1] = 0; loop[1] < end[1]; loop[1]++) {
      for (loop[0] = 0; loop[0] < end[0]; loop[0]++) {
        a.apply(_macroscopicCellsWithLinkedCells[linearIndex], linearIndex);
        linearIndex++;
      }
    }
  }
  a.endCellIteration();
}

template <class LinkedCell, unsigned int dim>
template <class A>
void coupling::datastructures::MacroscopicCells<LinkedCell, dim>::applyToFirstLayerOfGlobalNonGhostCellsWithLinkedCells(A& a) {
  // global coordinate of first non-ghost cell
  const tarch::la::Vector<dim, unsigned int> globalLowerLeftCorner(1);
  // global coordinate of last non-ghost cell
  const tarch::la::Vector<dim, unsigned int> globalUpperRightCorner(_indexConversion.getGlobalNumberMacroscopicCells());
  // start and end coordinates for all local non-ghost cells
  const tarch::la::Vector<3, unsigned int> start(1);
  const tarch::la::Vector<3, unsigned int> end = start + coupling::initRange<dim>(_indexConversion.getLocalNumberMacroscopicCells());
  tarch::la::Vector<3, unsigned int> loop(0);

  a.beginCellIteration();
  for (loop[2] = start[2]; loop[2] < end[2]; loop[2]++) {
    for (loop[1] = start[1]; loop[1] < end[1]; loop[1]++) {
      for (loop[0] = start[0]; loop[0] < end[0]; loop[0]++) {
        // get global coordinate of local cell
        const tarch::la::Vector<dim, unsigned> globalCoord = _indexConversion.convertLocalToGlobalVectorCellIndex(coupling::initDimVector<dim>(loop));
        bool isBoundary = false;
        for (unsigned int d = 0; d < dim; d++) {
          isBoundary = isBoundary || (globalCoord[d] == globalLowerLeftCorner[d]) || (globalCoord[d] == globalUpperRightCorner[d]);
        }
        if (isBoundary) {
          const unsigned int linearIndex = _indexConversion.getLocalCellIndex(coupling::initDimVector<dim>(loop));
          a.apply(_macroscopicCellsWithLinkedCells[linearIndex], linearIndex);
        }
      }
    }
  }
  a.endCellIteration();
}

template <class LinkedCell, unsigned int dim>
template <class A>
void coupling::datastructures::MacroscopicCells<LinkedCell, dim>::applyXLayersOfGlobalNonGhostCellsWithLinkedCells(A& a, unsigned int layers2Use) {
  // global coordinate of first non-ghost cell
  const tarch::la::Vector<dim, unsigned int> globalLowerLeftCorner(1 + layers2Use);
  // global coordinate of last non-ghost cell
  const tarch::la::Vector<dim, unsigned int> globalUpperRightCorner(_indexConversion.getGlobalNumberMacroscopicCells() -
                                                                    tarch::la::Vector<dim, unsigned int>(layers2Use));
  // start and end coordinates for all local non-ghost cells
  const tarch::la::Vector<3, unsigned int> start(1);
  const tarch::la::Vector<3, unsigned int> end = start + coupling::initRange<dim>(_indexConversion.getLocalNumberMacroscopicCells());
  tarch::la::Vector<3, unsigned int> loop(0);

  a.beginCellIteration();
  for (loop[2] = start[2]; loop[2] < end[2]; loop[2]++) {
    for (loop[1] = start[1]; loop[1] < end[1]; loop[1]++) {
      for (loop[0] = start[0]; loop[0] < end[0]; loop[0]++) {
        // get global coordinate of local cell
        const tarch::la::Vector<dim, unsigned> globalCoord = _indexConversion.convertLocalToGlobalVectorCellIndex(coupling::initDimVector<dim>(loop));
        bool isBoundary = false;
        for (unsigned int d = 0; d < dim; d++) {
          isBoundary = isBoundary || (globalCoord[d] <= globalLowerLeftCorner[d]) || (globalCoord[d] >= globalUpperRightCorner[d]);
        }
        if (isBoundary) {
          const unsigned int linearIndex = _indexConversion.getLocalCellIndex(coupling::initDimVector<dim>(loop));
          a.apply(_macroscopicCellsWithLinkedCells[linearIndex], linearIndex);
        }
      }
    }
  }
  a.endCellIteration();
}

template <class LinkedCell, unsigned int dim>
template <class A>
void coupling::datastructures::MacroscopicCells<LinkedCell, dim>::applyXLayersOfGlobalNonGhostCellsWithLinkedCellsAtBottom(A& a, unsigned int layers2Use) {
  // global coordinate of first non-ghost cell
  const tarch::la::Vector<dim, unsigned int> globalLowerLeftCorner(0, 0, layers2Use);
  // start and end coordinates for all local non-ghost cells
  const tarch::la::Vector<3, unsigned int> start(1);
  const tarch::la::Vector<3, unsigned int> end = start + coupling::initRange<dim>(_indexConversion.getLocalNumberMacroscopicCells());
  tarch::la::Vector<3, unsigned int> loop(0);

  a.beginCellIteration();
  for (loop[2] = start[2]; loop[2] < end[2]; loop[2]++) {
    for (loop[1] = start[1]; loop[1] < end[1]; loop[1]++) {
      for (loop[0] = start[0]; loop[0] < end[0]; loop[0]++) {
        // get global coordinate of local cell
        const tarch::la::Vector<dim, unsigned> globalCoord = _indexConversion.convertLocalToGlobalVectorCellIndex(coupling::initDimVector<dim>(loop));
        if (globalCoord[2] <= globalLowerLeftCorner[2]) {
          const unsigned int linearIndex = _indexConversion.getLocalCellIndex(coupling::initDimVector<dim>(loop));
          a.apply(_macroscopicCellsWithLinkedCells[linearIndex], linearIndex);
        }
      }
    }
  }
  a.endCellIteration();
}

template <class LinkedCell, unsigned int dim>
template <class A>
void coupling::datastructures::MacroscopicCells<LinkedCell, dim>::applyXLayersOfGlobalNonGhostCellsWithLinkedCellsAtTop(A& a, unsigned int layers2Use) {
  // global coordinate of last non-ghost cell
  const tarch::la::Vector<dim, unsigned int> globalUpperRightCorner(_indexConversion.getGlobalNumberMacroscopicCells() -
                                                                    tarch::la::Vector<dim, unsigned int>(0, 0, layers2Use - 1));
  // start and end coordinates for all local non-ghost cells
  const tarch::la::Vector<3, unsigned int> start(1);
  const tarch::la::Vector<3, unsigned int> end = start + coupling::initRange<dim>(_indexConversion.getLocalNumberMacroscopicCells());
  tarch::la::Vector<3, unsigned int> loop(0);

  a.beginCellIteration();
  for (loop[2] = start[2]; loop[2] < end[2]; loop[2]++) {
    for (loop[1] = start[1]; loop[1] < end[1]; loop[1]++) {
      for (loop[0] = start[0]; loop[0] < end[0]; loop[0]++) {
        // get global coordinate of local cell
        const tarch::la::Vector<dim, unsigned> globalCoord = _indexConversion.convertLocalToGlobalVectorCellIndex(coupling::initDimVector<dim>(loop));
        if (globalCoord[2] >= globalUpperRightCorner[2]) {
          const unsigned int linearIndex = _indexConversion.getLocalCellIndex(coupling::initDimVector<dim>(loop));
          a.apply(_macroscopicCellsWithLinkedCells[linearIndex], linearIndex);
        }
      }
    }
  }
  a.endCellIteration();
}

template <class LinkedCell, unsigned int dim>
std::vector<coupling::datastructures::MacroscopicCell<dim>*>
coupling::datastructures::MacroscopicCells<LinkedCell, dim>::initMacroscopicCells(const coupling::IndexConversion<dim>& indexConversion) const {
  // determine total number of cells
  const tarch::la::Vector<dim, unsigned int> localNumberCells = indexConversion.getLocalNumberMacroscopicCells() + tarch::la::Vector<dim, unsigned int>(2);
  unsigned int numberCells = localNumberCells[0];
  for (unsigned int d = 1; d < dim; d++) {
    numberCells = numberCells * localNumberCells[d];
  }

  // init vector with pointers to cells-with-linked-cells
  std::vector<coupling::datastructures::MacroscopicCell<dim>*> macroscopicCells;
  for (unsigned int i = 0; i < numberCells; i++) {
    coupling::datastructures::MacroscopicCell<dim>* cell = dynamic_cast<coupling::datastructures::MacroscopicCell<dim>*>(&_macroscopicCellsWithLinkedCells[i]);
    if (cell == NULL) {
      std::cout << "ERROR coupling::datastructures::MacroscopicCells::initMacroscopicCells(): dynamic_cast failed!" << std::endl;
      exit(EXIT_FAILURE);
    }
    macroscopicCells.push_back(cell);
  }
  return macroscopicCells;
}
